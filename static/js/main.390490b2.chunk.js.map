{"version":3,"sources":["utils/AlgorithmUtil.js","utils/Algorithms/AStar.js","utils/Algorithms/BFS.js","utils/Algorithms/DFS.js","utils/Algorithms/Greedy.js","utils/GridUtil.js","actions/index.js","components/Node.js","components/Grid.js","components/Navbar.js","components/Statbar.js","assets/images/BFS.gif","assets/images/A Star.gif","assets/images/Greedy.gif","assets/images/DFS.gif","components/Carousel.js","components/Menu.js","components/App.js","reducers/index.js","index.js"],"names":["isAlgorithmRunning","store","getState","algorithmStatus","isAlgorithmUnselected","isAlgorithmCompleted","isAlgorithmReady","nodeEquals","node_1","node_2","row","col","getNeighbors","node","neighbors","Array","dy","dx","i","length","push","shouldAddNode","grid","allowDuplicateFrontier","m","n","j","isVisitedNode","isWallNode","isFrontierNode","tracePath","endNode","togglePathNode","a","stack","Stack","parent","size","pop","sleep","setPath","isPathNode","duration","Promise","resolve","setTimeout","calculateManhattanDistance","start","end","Math","abs","generateCostGrid","costGrid","runAStar","algorithmState","startNode","toggleVisitedNode","toggleFrontierNode","completeAlgorithm","setParentNode","setEstimateValues","priorityQueue","Heap","f","h","currNode","neighbor","g","runBFS","queue","Queue","enqueue","dequeue","runDFS","runGreedy","Node","this","isStartNode","isEndNode","Statistic","numTotal","numVisited","numFrontier","numWall","numPath","generateEmptyGrid","numRows","numCols","calculateStatistics","statistics","generateRerunAlgorithmGrid","algorithmSelected","slice","rerunBFS","rerunDFS","rerunAStar","rerunGreedy","setVisitedNode","setWallNode","setFrontierNode","setPathNode","setStartNode","initializeStartNode","setEndNode","initializeEndNode","applyMaskedNode","maskedNode","calculateMaskedStatistic","newMaskedNode","generateWalls","random","clearBoard","initializeStatistics","clearPath","SET_BFS_ALGORITHM","SET_DFS_ALGORITHM","SET_ASTAR_ALGORITHM","SET_GREEDY_ALGORITHM","TOGGLE_VISITED_NODE","TOGGLE_FRONTIER_NODE","TOGGLE_WALL_NODE","TOGGLE_PATH_NODE","SET_ALGORITHM_STATE","CLEAR_ALGORITHM_STATE","SET_START_NODE","SET_END_NODE","RUN_ALGORITHM","READY_ALGORITHM","PAUSE_ALGORITHM","COMPLETE_ALGORITHM","SET_PARENT_NODE","GENERATE_WALLS","CLEAR_BOARD","CLEAR_PATH","SET_DRAGGED_NODE","CLEAR_DRAGGED_NODE","SET_START_MASKED_NODE","APPLY_START_MASKED_NODE","RERUN_ALGORITHM","RESET_START_MASKED_NODE","SET_END_MASKED_NODE","APPLY_END_MASKED_NODE","RESET_END_MASKED_NODE","SET_ESTIMATE_VALUES","type","payload","resetStartMaskedNode","resetEndMaskedNode","connect","state","ownProps","board","draggedNode","dispatch","toggleWallNode","setDraggedNode","clearDraggedNode","setStartMaskedNode","setEndMaskedNode","applyStartMaskedNode","applyEndMaskedNode","rerunAlgorithm","nodeClass","className","onMouseOver","onMouseUp","onMouseDown","props","map","cellRow","cell","toString","generateCellKey","generateRowKey","Navbar","runButtonText","runButtonClass","runAlgorithm","readyAlgorithm","clearAlgorithmState","toggleShowCarousel","runButtonDisabled","generateWallsButtonDisabled","onClick","disabled","Carousel","setBFSAlgorithm","setDFSAlgorithm","setAStarAlgorithm","setGreedyAlgorithm","algorithms","name","header","gif","BFS_GIF","description","DFS_GIF","AStar_GIF","Greedy_GIF","useState","slideNum","setSlideNum","wrapperRef","useRef","useEffect","handleClickOutside","event","current","contains","target","document","addEventListener","removeEventListener","mod","ref","src","alt","handleClickSelect","setAlgorithmState","pauseAlgorithm","showCarousel","setShowCarousel","App","reducer","combineReducers","startMaskedNode","endMaskedNode","action","createStore","window","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.390490b2.chunk.js","sourcesContent":["import store from \"../\"\r\nimport Stack from 'mnemonist/stack'\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    return store.getState().algorithmStatus === 'RUNNING'\r\n}\r\n\r\nexport const isAlgorithmUnselected = () => {\r\n    return store.getState().algorithmStatus === 'UNSELECTED'\r\n}\r\n\r\nexport const isAlgorithmCompleted = () => {\r\n    return store.getState().algorithmStatus === 'COMPLETED'\r\n}\r\n\r\nexport const isAlgorithmReady = () => {\r\n    return store.getState().algorithmStatus === 'READY'\r\n}\r\n\r\nexport const nodeEquals = (node_1, node_2) => {\r\n    return node_1.row === node_2.row && node_1.col === node_2.col\r\n}\r\n\r\nexport const getNeighbors = (node) => {\r\n    const neighbors = new Array(0)\r\n    const dy = [0, 0, -1, 1]  // directions of i\r\n    const dx = [1, -1, 0, 0]  // directions of j\r\n    for (let i = 0; i < dy.length; i++) {\r\n        neighbors.push({ row: node.row + dy[i], col: node.col + dx[i] })\r\n    }\r\n    return neighbors\r\n}\r\n\r\n// Enqueue the Node only if it is within the range of the grid, not visited, not a frontier and not a wall node\r\nexport const shouldAddNode = (node, grid, allowDuplicateFrontier = false) => {\r\n    const m = grid.length\r\n    const n = grid[0].length\r\n    const i = node.row\r\n    const j = node.col\r\n    return i >= 0 && i < m && j >= 0 && j < n && !grid[i][j].isVisitedNode && !grid[i][j].isWallNode && \r\n        (!grid[i][j].isFrontierNode || allowDuplicateFrontier)\r\n}\r\n\r\nexport const tracePath = async (endNode, grid, togglePathNode) => {\r\n    let node = endNode\r\n    const stack = new Stack() \r\n    while (node != null) {\r\n        stack.push(node)\r\n        node = grid[node.row][node.col].parent\r\n    }\r\n    while (stack.size > 0) {\r\n        node = stack.pop()\r\n        togglePathNode(node.row, node.col)\r\n        await sleep(40)\r\n    }\r\n}\r\n\r\n// This sets the path immediately\r\n// without having the trace animation (no intervals between each path node animation)\r\nexport const setPath = (endNode, grid) => {\r\n    let node = endNode\r\n    const stack = new Stack() \r\n    while (node != null) {\r\n        stack.push(node)\r\n        node = grid[node.row][node.col].parent\r\n    }\r\n    while (stack.size > 0) {\r\n        node = stack.pop()\r\n        grid[node.row][node.col].isPathNode = true\r\n    }\r\n}\r\n\r\nexport const sleep = (duration) => {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, duration)\r\n    })\r\n}\r\n\r\nexport const calculateManhattanDistance = (start, end) => {\r\n    return Math.abs(start.row - end.row) + Math.abs(start.col - end.col)\r\n}","import { isAlgorithmRunning, nodeEquals, shouldAddNode, getNeighbors, \r\n    sleep, tracePath, setPath, calculateManhattanDistance } from '../AlgorithmUtil'\r\nimport Heap from 'mnemonist/heap';\r\n\r\nconst generateCostGrid = (m, n) => {\r\n    const costGrid = []\r\n    for (let i = 0; i < m; i++) {\r\n        const row = []\r\n        for (let j = 0; j < n; j++) {\r\n            row.push(null)\r\n        }\r\n        costGrid.push(row)\r\n    }\r\n    return costGrid\r\n}\r\n\r\nexport const runAStar = async (algorithmState, grid, startNode, endNode, toggleVisitedNode, toggleFrontierNode,\r\n    togglePathNode, completeAlgorithm, setParentNode, setEstimateValues) => {\r\n        \r\n    // While the algorithm has not been completed or paused\r\n    while (isAlgorithmRunning()) {\r\n        // Create a new priorityQueue if the current algorithm state is empty; this is the first iteration\r\n\r\n        if (!algorithmState) {\r\n            const priorityQueue = new Heap((node_1, node_2) => {\r\n                return grid[node_1.row][node_1.col].f - grid[node_2.row][node_2.col].f\r\n            })\r\n            const costGrid = generateCostGrid(grid.length, grid[0].length)  // contains the best cost so far to travel to every node (g-value)\r\n            algorithmState = { priorityQueue, costGrid }\r\n            const h = calculateManhattanDistance(startNode, endNode)\r\n            const g = 0\r\n            const f = h + g\r\n            setEstimateValues(startNode.row, startNode.col, f, g, h)\r\n            priorityQueue.push(startNode)\r\n            toggleFrontierNode(startNode.row, startNode.col)\r\n            costGrid[startNode.row][startNode.col] = 0\r\n        }\r\n\r\n        const { priorityQueue, costGrid } = algorithmState\r\n\r\n        if (priorityQueue.size === 0) {  // No path was found\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        // Perform one iteration of A Star\r\n        const currNode = priorityQueue.pop()\r\n        if (!grid[currNode.row][currNode.col].isVisitedNode) {  // Skip over nodes already visited; the optimal path to this node already found\r\n            toggleVisitedNode(currNode.row, currNode.col)\r\n            toggleFrontierNode(currNode.row, currNode.col)  // this node is no longer a frontier node\r\n        }\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            await tracePath(endNode, grid, togglePathNode)\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid, true)) {\r\n                const g = grid[currNode.row][currNode.col].g + 1\r\n                if (costGrid[neighbor.row][neighbor.col] === null ||  g < costGrid[neighbor.row][neighbor.col]) {\r\n                    const h = calculateManhattanDistance(neighbor, endNode)\r\n                    const f = h + g\r\n                    setEstimateValues(neighbor.row, neighbor.col, f, g, h)\r\n                    if (costGrid[neighbor.row][neighbor.col] === null)  // only set to frontier node if there are no duplicates in the heap\r\n                        toggleFrontierNode(neighbor.row, neighbor.col)\r\n                    setParentNode(neighbor.row, neighbor.col, { ...currNode })\r\n                    priorityQueue.push(neighbor)\r\n                    costGrid[neighbor.row][neighbor.col] = g\r\n                }\r\n            }\r\n        }\r\n\r\n        // Timeout ensures that the animation has enough time to render fully\r\n        await sleep(20)\r\n\r\n    }\r\n\r\n    return algorithmState\r\n\r\n}\r\n\r\n// Run the algorithm on the grid and return the grid state\r\n// corresponding to the completed algorithm \r\n// (rerun does not have the tracing animation; no timeout between each node visit => instantaneous render of traversed graph)\r\nexport const rerunAStar = (grid, startNode, endNode) => {\r\n    const priorityQueue = new Heap((node_1, node_2) => {\r\n        return grid[node_1.row][node_1.col].f - grid[node_2.row][node_2.col].f\r\n    })\r\n    const costGrid = generateCostGrid(grid.length, grid[0].length)  // contains the best cost so far to travel to every node (g-value)\r\n    const h = calculateManhattanDistance(startNode, endNode)\r\n    const g = 0\r\n    const f = h + g\r\n    grid[startNode.row][startNode.col].f = f\r\n    grid[startNode.row][startNode.col].g = g\r\n    grid[startNode.row][startNode.col].h = h\r\n    priorityQueue.push(startNode)\r\n    costGrid[startNode.row][startNode.col] = 0\r\n\r\n    while (priorityQueue.size > 0) {\r\n        const currNode = priorityQueue.pop()\r\n        \r\n        grid[currNode.row][currNode.col].isVisitedNode = true\r\n        grid[currNode.row][currNode.col].isFrontierNode = false  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            setPath(endNode, grid)\r\n            break\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid, true)) {\r\n                const g = grid[currNode.row][currNode.col].g + 1\r\n                if (costGrid[neighbor.row][neighbor.col] === null ||  g < costGrid[neighbor.row][neighbor.col]) {\r\n                    const h = calculateManhattanDistance(neighbor, endNode)\r\n                    const f = h + g\r\n                    grid[neighbor.row][neighbor.col].f = f\r\n                    grid[neighbor.row][neighbor.col].g = g\r\n                    grid[neighbor.row][neighbor.col].h = h\r\n                    if (costGrid[neighbor.row][neighbor.col] === null)  // only set to frontier node if there are no duplicates in the heap\r\n                        grid[neighbor.row][neighbor.col].isFrontierNode = true\r\n                    grid[neighbor.row][neighbor.col].parent = { ...currNode }\r\n                    priorityQueue.push(neighbor)\r\n                    costGrid[neighbor.row][neighbor.col] = g\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return grid\r\n}","import { isAlgorithmRunning, nodeEquals, shouldAddNode, getNeighbors, \r\n    sleep, tracePath, setPath } from '../AlgorithmUtil'\r\nimport Queue from 'mnemonist/queue'\r\n\r\nexport const runBFS = async (queue, grid, startNode, endNode, toggleVisitedNode, toggleFrontierNode,\r\n    togglePathNode, completeAlgorithm, setParentNode) => {\r\n        \r\n    // While the algorithm has not been completed or paused\r\n    while (isAlgorithmRunning()) {\r\n        \r\n        // Create a new queue if the current algorithm state is empty; this is the first iteration\r\n        if (!queue) {\r\n            queue = new Queue()\r\n            queue.enqueue(startNode)\r\n            toggleFrontierNode(startNode.row, startNode.col)\r\n        }\r\n\r\n        if (queue.size === 0) {  // No path was found\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        // Perform one iteration of BFS\r\n        const currNode = queue.dequeue()\r\n        toggleVisitedNode(currNode.row, currNode.col)\r\n        toggleFrontierNode(currNode.row, currNode.col)  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            await tracePath(endNode, grid, togglePathNode)\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid)) {\r\n                toggleFrontierNode(neighbor.row, neighbor.col)\r\n                setParentNode(neighbor.row, neighbor.col, { ...currNode })\r\n                queue.enqueue(neighbor)\r\n            }\r\n        }\r\n\r\n        // Timeout ensures that the animation has enough time to render fully\r\n        await sleep(20)\r\n\r\n    }\r\n\r\n    return queue\r\n\r\n}\r\n\r\n// Run the algorithm on the grid and return the grid state\r\n// corresponding to the completed algorithm \r\n// (rerun does not have the tracing animation; no timeout between each node visit => instantaneous render of traversed graph)\r\nexport const rerunBFS = (grid, startNode, endNode) => {\r\n    const queue = new Queue()\r\n    queue.enqueue(startNode)\r\n    while (queue.size > 0) {\r\n        const currNode = queue.dequeue()\r\n        grid[currNode.row][currNode.col].isVisitedNode = true\r\n        grid[currNode.row][currNode.col].isFrontierNode = false  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            setPath(endNode, grid)\r\n            break\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid)) {\r\n                grid[neighbor.row][neighbor.col].isFrontierNode = true\r\n                grid[neighbor.row][neighbor.col].parent = { ...currNode }\r\n                queue.enqueue(neighbor)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return grid\r\n}","import { isAlgorithmRunning, nodeEquals, shouldAddNode, getNeighbors, \r\n    sleep, tracePath, setPath } from '../AlgorithmUtil'\r\nimport Stack from 'mnemonist/stack'\r\n\r\nexport const runDFS = async (stack, grid, startNode, endNode, toggleVisitedNode, toggleFrontierNode,\r\n    togglePathNode, completeAlgorithm, setParentNode) => {\r\n        \r\n    // While the algorithm has not been completed or paused\r\n    while (isAlgorithmRunning()) {\r\n        \r\n        // Create a new stack if the current algorithm state is empty; this is the first iteration\r\n        if (!stack) {\r\n            stack = new Stack()\r\n            stack.push(startNode)\r\n            toggleFrontierNode(startNode.row, startNode.col)\r\n        }\r\n\r\n        if (stack.size === 0) {  // No path was found\r\n            completeAlgorithm()  // set the status to COMPLETED\r\n            return\r\n        }\r\n\r\n        // Perform one iteration of DFS\r\n        const currNode = stack.pop()\r\n        toggleVisitedNode(currNode.row, currNode.col)\r\n        toggleFrontierNode(currNode.row, currNode.col)  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            await tracePath(endNode, grid, togglePathNode)\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid)) {\r\n                toggleFrontierNode(neighbor.row, neighbor.col)\r\n                setParentNode(neighbor.row, neighbor.col, { ...currNode })\r\n                stack.push(neighbor)\r\n            }\r\n        }\r\n\r\n        // Timeout ensures that the animation has enough time to render fully\r\n        await sleep(20)\r\n\r\n    }\r\n\r\n    return stack\r\n\r\n}\r\n\r\n// Run the algorithm on the grid and return the grid state\r\n// corresponding to the completed algorithm \r\n// (rerun does not have the tracing animation; no timeout between each node visit => instantaneous render of traversed graph)\r\nexport const rerunDFS = (grid, startNode, endNode) => {\r\n    const stack = new Stack()\r\n    stack.push(startNode)\r\n    while (stack.size > 0) {\r\n        const currNode = stack.pop()\r\n        grid[currNode.row][currNode.col].isVisitedNode = true\r\n        grid[currNode.row][currNode.col].isFrontierNode = false  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            setPath(endNode, grid)\r\n            break\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid)) {\r\n                grid[neighbor.row][neighbor.col].isFrontierNode = true\r\n                grid[neighbor.row][neighbor.col].parent = { ...currNode }\r\n                stack.push(neighbor)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return grid\r\n}","import { isAlgorithmRunning, nodeEquals, shouldAddNode, getNeighbors, \r\n    sleep, tracePath, setPath, calculateManhattanDistance } from '../AlgorithmUtil'\r\nimport Heap from 'mnemonist/heap'\r\n\r\nexport const runGreedy = async (priorityQueue, grid, startNode, endNode, toggleVisitedNode, toggleFrontierNode,\r\n    togglePathNode, completeAlgorithm, setParentNode, setEstimateValues) => {\r\n        \r\n    // While the algorithm has not been completed or paused\r\n    while (isAlgorithmRunning()) {\r\n        // Create a new priorityQueue if the current algorithm state is empty; this is the first iteration\r\n        if (!priorityQueue) {\r\n            priorityQueue = new Heap((node_1, node_2) => {\r\n                return grid[node_1.row][node_1.col].f - grid[node_2.row][node_2.col].f\r\n            })\r\n            const f = calculateManhattanDistance(startNode, endNode)\r\n            setEstimateValues(startNode.row, startNode.col, f, null, null)\r\n            priorityQueue.push(startNode)\r\n            toggleFrontierNode(startNode.row, startNode.col)\r\n        }\r\n\r\n        if (priorityQueue.size === 0) {  // No path was found\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        // Perform one iteration of Greedy\r\n        const currNode = priorityQueue.pop()\r\n        toggleVisitedNode(currNode.row, currNode.col)\r\n        toggleFrontierNode(currNode.row, currNode.col)  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            await tracePath(endNode, grid, togglePathNode)\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid)) {\r\n                const f = calculateManhattanDistance(neighbor, endNode)\r\n                setEstimateValues(neighbor.row, neighbor.col, f, null, null)\r\n                toggleFrontierNode(neighbor.row, neighbor.col)\r\n                setParentNode(neighbor.row, neighbor.col, { ...currNode })\r\n                priorityQueue.push(neighbor)\r\n            }\r\n        }\r\n\r\n        // Timeout ensures that the animation has enough time to render fully\r\n        await sleep(20)\r\n\r\n    }\r\n\r\n    return priorityQueue\r\n\r\n}\r\n\r\n// Run the algorithm on the grid and return the grid state\r\n// corresponding to the completed algorithm \r\n// (rerun does not have the tracing animation; no timeout between each node visit => instantaneous render of traversed graph)\r\nexport const rerunGreedy = (grid, startNode, endNode) => {\r\n    const priorityQueue = new Heap((node_1, node_2) => {\r\n        return grid[node_1.row][node_1.col].f - grid[node_2.row][node_2.col].f\r\n    })\r\n    const f = calculateManhattanDistance(startNode, endNode)\r\n    grid[startNode.row][startNode.col].f = f\r\n    priorityQueue.push(startNode)\r\n    while (priorityQueue.size > 0) {\r\n        const currNode = priorityQueue.pop()\r\n        grid[currNode.row][currNode.col].isVisitedNode = true\r\n        grid[currNode.row][currNode.col].isFrontierNode = false  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            setPath(endNode, grid)\r\n            break\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldAddNode(neighbor, grid)) {\r\n                const f = calculateManhattanDistance(neighbor, endNode)\r\n                grid[neighbor.row][neighbor.col].f = f\r\n                grid[neighbor.row][neighbor.col].isFrontierNode = true\r\n                grid[neighbor.row][neighbor.col].parent = { ...currNode }\r\n                priorityQueue.push(neighbor)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return grid\r\n}","import { rerunAStar } from \"./Algorithms/AStar\"\r\nimport { rerunBFS } from \"./Algorithms/BFS\"\r\nimport { rerunDFS } from \"./Algorithms/DFS\"\r\nimport { rerunGreedy } from \"./Algorithms/Greedy\"\r\n\r\n// Node constructor\r\nexport function Node() {\r\n    this.isStartNode = false\r\n    this.isEndNode = false\r\n    this.isWallNode = false\r\n    this.isFrontierNode = false\r\n    this.isVisitedNode = false\r\n    this.isPathNode = false\r\n    this.parent = null  // coordinates of the parent\r\n    this.g = null  // to be used by Astar and Greedy algorithms\r\n    this.h = null\r\n    this.f = null\r\n}\r\n\r\nexport const initializeStartNode = () => {\r\n    const node = new Node()\r\n    node.isStartNode = true\r\n    return node\r\n}\r\n\r\nexport const initializeEndNode = () => {\r\n    const node = new Node()\r\n    node.isEndNode = true\r\n    return node\r\n}\r\n\r\nfunction Statistic(numTotal) {\r\n    this.numTotal = numTotal\r\n    this.numVisited = 0\r\n    this.numFrontier = 0\r\n    this.numWall = 0\r\n    this.numPath = 0\r\n}\r\n\r\n// Key generators for React Grid mapping to rows and cells\r\nexport const generateRowKey = (row) => {\r\n    return row.toString()\r\n}\r\n\r\nexport const generateCellKey = (row, col) => {\r\n    return row.toString() + '#' + col.toString()\r\n}\r\n\r\n// Utilities for generating grids\r\nexport const generateEmptyGrid = (numRows, numCols, startNode, endNode) => {\r\n    const grid = new Array(0)\r\n    for (let i = 0; i < numRows; i++) {\r\n        grid.push(new Array(0))\r\n        for (let j = 0; j < numCols; j++) {\r\n            grid[i].push(new Node())\r\n        }\r\n    }\r\n    grid[startNode.row][startNode.col].isStartNode = true\r\n    grid[endNode.row][endNode.col].isEndNode = true\r\n    return grid\r\n}\r\n\r\nconst calculateStatistics = (grid) => {\r\n    const numRows = grid.length\r\n    const numCols = grid[0].length\r\n    const statistics = new Statistic(numRows * numCols)\r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            statistics.numWall += grid[i][j].isWallNode ? 1 : 0\r\n            statistics.numVisited += grid[i][j].isVisitedNode ? 1 : 0\r\n            statistics.numFrontier += grid[i][j].isFrontierNode ? 1 : 0\r\n            statistics.numPath += grid[i][j].isPathNode ? 1 : 0\r\n        }\r\n    }\r\n    return statistics\r\n}\r\n\r\nexport const generateRerunAlgorithmGrid = (grid, startNode, endNode, algorithmSelected) => {\r\n    grid = grid.slice()\r\n    switch (algorithmSelected) {\r\n        case 'BFS':\r\n            grid = rerunBFS(grid, startNode, endNode)\r\n            break\r\n        case 'DFS':\r\n            grid = rerunDFS(grid, startNode, endNode)\r\n            break\r\n        case 'ASTAR':\r\n            grid = rerunAStar(grid, startNode, endNode)\r\n            break\r\n        case 'GREEDY':\r\n            grid = rerunGreedy(grid, startNode, endNode)\r\n            break\r\n        default:\r\n            break\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: calculateStatistics(grid) \r\n    }\r\n}\r\n\r\nexport const setVisitedNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isVisitedNode = !node.isVisitedNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numVisited: node.isVisitedNode ? statistics.numVisited + 1 : statistics.numVisited - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setWallNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isWallNode = !node.isWallNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numWall: node.isWallNode ? statistics.numWall + 1 : statistics.numWall - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setFrontierNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isFrontierNode = !node.isFrontierNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numFrontier: node.isFrontierNode ? statistics.numFrontier + 1 : statistics.numFrontier - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setPathNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isPathNode = !node.isPathNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numPath: node.isPathNode ? statistics.numPath + 1 : statistics.numPath - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setStartNode = (grid, {row, col}) => {\r\n    grid = grid.slice()\r\n    grid[row][col] = initializeStartNode()\r\n    return grid\r\n}\r\n\r\nexport const setEndNode = (grid, {row, col}) => {\r\n    grid = grid.slice()\r\n    grid[row][col] = initializeEndNode()\r\n    return grid\r\n}\r\n\r\nexport const setParentNode = (grid, {row, col, parent}) => {\r\n    grid = grid.slice()\r\n    grid[row][col].parent = parent;\r\n    return grid\r\n}\r\n\r\nexport const setEstimateValues = (grid, {f, g, h, row, col}) => {\r\n    grid = grid.slice()\r\n    grid[row][col].f = f;\r\n    grid[row][col].g = g;\r\n    grid[row][col].h = h;\r\n    return grid\r\n}\r\n\r\nexport const applyMaskedNode = (grid, statistics, {row, col}, maskedNode) => {\r\n    grid = grid.slice()\r\n    \r\n    grid[row][col] = { ...maskedNode };\r\n    return { \r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numWall: statistics.numWall + (maskedNode.isWallNode ? 1 : 0),\r\n        }\r\n    }\r\n}\r\n\r\nexport const calculateMaskedStatistic = (grid, statistics, {row, col}) => {\r\n    const newMaskedNode = grid[row][col]\r\n    return {\r\n        statistics: {\r\n            ...statistics,\r\n            numWall: statistics.numWall - (newMaskedNode.isWallNode ? 1 : 0),\r\n        }\r\n    }\r\n}\r\n\r\nexport const generateWalls = (grid, statistics) => {\r\n    grid = grid.slice()\r\n    const p = 0.3  // probability that a node becomes a wall node \r\n    let numWall = 0\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const node = grid[i][j]\r\n            if (!node.isStartNode && !node.isEndNode && Math.random() <= p) {\r\n                node.isWallNode = true\r\n                numWall++\r\n            } else {\r\n                node.isWallNode = false\r\n            }\r\n        }\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: {\r\n            ...statistics,\r\n            numWall\r\n        }\r\n    }\r\n}\r\n\r\nexport const clearBoard = (grid, startNode, endNode) => {\r\n    grid = grid.slice()\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            grid[i][j] = new Node()\r\n        }\r\n    }\r\n    grid[startNode.row][startNode.col].isStartNode = true\r\n    grid[endNode.row][endNode.col].isEndNode = true\r\n    return { \r\n        grid, \r\n        statistics: initializeStatistics(grid.length, grid[0].length)\r\n    }\r\n}\r\n\r\nexport const clearPath = (grid, statistics) => {\r\n    grid = grid.slice()\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const node = grid[i][j]\r\n            node.isPathNode = false\r\n            node.isVisitedNode = false\r\n            node.isFrontierNode = false\r\n            node.parent = null\r\n            node.g = null\r\n            node.f = null\r\n            node.h = null\r\n        }\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: {\r\n            ...statistics,\r\n            numPath: 0,\r\n            numFrontier: 0,\r\n            numVisited: 0\r\n        }\r\n    }\r\n}\r\n\r\n// Utilities for generating statistics\r\nexport const initializeStatistics = (numRows, numCols) => {\r\n    return new Statistic(numRows * numCols)\r\n}","// create and export types for our actions\r\nexport const SET_BFS_ALGORITHM = \"SET_BFS_ALGORITHM\"\r\nexport const SET_DFS_ALGORITHM = \"SET_DFS_ALGORITHM\"\r\nexport const SET_ASTAR_ALGORITHM = \"SET_ASTAR_ALGORITHM\"\r\nexport const SET_GREEDY_ALGORITHM = \"SET_GREEDY_ALGORITHM\"\r\nexport const TOGGLE_VISITED_NODE = \"TOGGLE_VISITED_NODE\"\r\nexport const TOGGLE_FRONTIER_NODE = \"TOGGLE_FRONTIER_NODE\"\r\nexport const TOGGLE_WALL_NODE = \"TOGGLE_WALL_NODE\"\r\nexport const TOGGLE_PATH_NODE = \"TOGGLE_PATH_NODE\"\r\nexport const SET_ALGORITHM_STATE = \"SET_ALGORITHM_STATE\"\r\nexport const CLEAR_ALGORITHM_STATE = \"CLEAR_ALGORITHM_STATE\"\r\nexport const SET_START_NODE = \"SET_START_NODE\"\r\nexport const SET_END_NODE = \"SET_END_NODE\"\r\nexport const RUN_ALGORITHM = \"RUN_ALGORITHM\"\r\nexport const READY_ALGORITHM = \"READY_ALGORITHM\"\r\nexport const PAUSE_ALGORITHM = \"PAUSE_ALGORITHM\"\r\nexport const COMPLETE_ALGORITHM = \"COMPLETE_ALGORITHM\" \r\nexport const SET_PARENT_NODE = \"SET_PARENT_NODE\"\r\nexport const GENERATE_WALLS = \"GENERATE_WALLS\"\r\nexport const CLEAR_BOARD = \"CLEAR_BOARD\"\r\nexport const CLEAR_PATH = \"CLEAR_PATH\"\r\nexport const SET_DRAGGED_NODE = \"SET_DRAGGED_NODE\"\r\nexport const CLEAR_DRAGGED_NODE = \"CLEAR_DRAGGED_NODE\"\r\nexport const SET_START_MASKED_NODE = \"SET_START_MASKED_NODE\"\r\nexport const APPLY_START_MASKED_NODE = \"APPLY_START_MASKED_NODE\"\r\nexport const RERUN_ALGORITHM = \"RERUN_ALGORITHM\"\r\nexport const RESET_START_MASKED_NODE = \"RESET_START_MASKED_NODE\"\r\nexport const SET_END_MASKED_NODE = \"SET_END_MASKED_NODE\"\r\nexport const APPLY_END_MASKED_NODE = \"APPLY_END_MASKED_NODE\"\r\nexport const RESET_END_MASKED_NODE = \"RESET_END_MASKED_NODE\"\r\nexport const SET_ESTIMATE_VALUES = \"SET_ESTIMATE_VALUES\"\r\n\r\n\r\n// action creators for grid state\r\nexport const rerunAlgorithm = (algorithmSelected) => {\r\n    return {\r\n        type: RERUN_ALGORITHM,\r\n        payload: { algorithmSelected }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_VISITED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_FRONTIER_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_WALL_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_PATH_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setParentNode = (row, col, parent) => {\r\n    return {\r\n        type: SET_PARENT_NODE,\r\n        payload: {row, col, parent}\r\n    }\r\n}\r\n\r\nexport const generateWalls = () => {\r\n    return {\r\n        type: GENERATE_WALLS\r\n    }\r\n}\r\n\r\nexport const clearBoard = () => {\r\n    return {\r\n        type: CLEAR_BOARD\r\n    }\r\n}\r\n\r\nexport const clearPath = () => {\r\n    return {\r\n        type: CLEAR_PATH\r\n    }\r\n}\r\n\r\nexport const setEstimateValues = (row, col, f, g, h) => {\r\n    return {\r\n        type: SET_ESTIMATE_VALUES,\r\n        payload: {f, g, h, row, col}\r\n    }\r\n}\r\n\r\n// action creators for algorithm state\r\n\r\nexport const runAlgorithm = () => {\r\n    return {\r\n        type: RUN_ALGORITHM,\r\n    }\r\n};\r\n\r\nexport const readyAlgorithm = () => {\r\n    return {\r\n        type: READY_ALGORITHM,\r\n    }\r\n};\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return {\r\n        type: PAUSE_ALGORITHM,\r\n    }\r\n};\r\n\r\nexport const completeAlgorithm = () => {\r\n    return {\r\n        type: COMPLETE_ALGORITHM,\r\n    }\r\n};\r\n\r\n\r\nexport const setBFSAlgorithm = () => {\r\n    return {\r\n        type: SET_BFS_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setDFSAlgorithm = () => {\r\n    return {\r\n        type: SET_DFS_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setAStarAlgorithm = () => {\r\n    return {\r\n        type: SET_ASTAR_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setGreedyAlgorithm = () => {\r\n    return {\r\n        type: SET_GREEDY_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setAlgorithmState = (algorithmState) => {\r\n    return {\r\n        type: SET_ALGORITHM_STATE,\r\n        payload: algorithmState\r\n    }\r\n}\r\n\r\nexport const clearAlgorithmState = () => {\r\n    return {\r\n        type: CLEAR_ALGORITHM_STATE\r\n    }\r\n}\r\n\r\n// action creators for tracking nodes\r\nexport const setStartNode = (row, col) => {\r\n    return {\r\n        type: SET_START_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setEndNode = (row, col) => {\r\n    return {\r\n        type: SET_END_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setDraggedNode = (row, col) => {\r\n    return {\r\n        type: SET_DRAGGED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const clearDraggedNode = (row, col) => {\r\n    return {\r\n        type: CLEAR_DRAGGED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setStartMaskedNode = (row, col) => {\r\n    return {\r\n        type: SET_START_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\n\r\nexport const applyStartMaskedNode = (row, col) => {\r\n    return {\r\n        type: APPLY_START_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setEndMaskedNode = (row, col) => {\r\n    return {\r\n        type: SET_END_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\n\r\nexport const applyEndMaskedNode = (row, col) => {\r\n    return {\r\n        type: APPLY_END_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const resetStartMaskedNode = () => {\r\n    return {\r\n        type: RESET_START_MASKED_NODE\r\n    }\r\n}\r\n\r\nexport const resetEndMaskedNode = () => {\r\n    return {\r\n        type: RESET_END_MASKED_NODE\r\n    }\r\n}","import React from 'react'\r\nimport '../css/Node.css'\r\nimport { connect } from 'react-redux'\r\nimport { toggleWallNode, setDraggedNode, clearDraggedNode, setStartNode, setEndNode, setStartMaskedNode, setEndMaskedNode, \r\n    setParentNode, rerunAlgorithm, clearPath, applyStartMaskedNode, applyEndMaskedNode, resetEndMaskedNode, resetStartMaskedNode } from '../actions'\r\nimport { nodeEquals, isAlgorithmCompleted, isAlgorithmUnselected, isAlgorithmReady } from '../utils/AlgorithmUtil'\r\n\r\nfunction Node({isVisitedNode, isWallNode, isEndNode, isStartNode, isFrontierNode, isPathNode,\r\n    toggleWallNode, row, col, startNode, endNode, draggedNode, setDraggedNode, clearDraggedNode,\r\n    setStartNode, setEndNode, setStartMaskedNode, applyStartMaskedNode, algorithmSelected, rerunAlgorithm,\r\n    clearPath, setEndMaskedNode, applyEndMaskedNode }) {\r\n\r\n    const handleMouseOver = () => {\r\n        if (draggedNode) {  // if there was a node being dragged to this position\r\n            if (draggedNode.isWallNode && !isVisitedNode && !isFrontierNode && !isWallNode && !isStartNode && !isEndNode) {\r\n                toggleWallNode(row, col)  // only allow toggling of wall boolean for unvisited/grey nodes and wall nodes\r\n            } else if (draggedNode.isStartNode && !isEndNode) {  // do not allow dragging start node over end node\r\n                applyStartMaskedNode(draggedNode.row, draggedNode.col)  // restore masked node properties back to the node we came from\r\n                if (isAlgorithmCompleted()) \r\n                    clearPath()\r\n                setStartMaskedNode(row, col)  // save the state of this node, to be reapplied to this node if we drag to somewhere else\r\n                setStartNode(row, col)  // replace the state of this node\r\n                setDraggedNode(row, col)  // update the dragged node to be this node\r\n\r\n                if (isAlgorithmCompleted()) {  // if the algorithm has status completed, run the algorithm instantly\r\n                    rerunAlgorithm(algorithmSelected)  // draw the new path, visited and frontier nodes for this new start position\r\n                }\r\n            } else if (draggedNode.isEndNode && !isStartNode) {  // do not allow dragging end node over start node\r\n                applyEndMaskedNode(draggedNode.row, draggedNode.col)  // restore masked node properties back to the node we came from\r\n                if (isAlgorithmCompleted()) \r\n                    clearPath()\r\n                setEndMaskedNode(row, col)  // save the state of this node, to be reapplied to this node if we drag to somewhere else\r\n                setEndNode(row, col)  // replace the state of this node\r\n                setDraggedNode(row, col)  // update the dragged node to be this node\r\n\r\n                if (isAlgorithmCompleted()) {  // if the algorithm has status completed, run the algorithm instantly\r\n                    rerunAlgorithm(algorithmSelected)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const handleMouseDown = () => {\r\n        if (isAlgorithmReady() || isAlgorithmCompleted() || isAlgorithmUnselected()) {  // only allow interactions with the grid when not running\r\n            if (!nodeEquals({row, col}, startNode) && !nodeEquals({row, col}, endNode) && !isVisitedNode && !isFrontierNode && !isPathNode)\r\n                toggleWallNode(row, col)\r\n            setDraggedNode(row, col)  // this is the current node being dragged\r\n        }\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n        clearDraggedNode()\r\n    }\r\n\r\n    let nodeClass\r\n    if (isStartNode) {\r\n        nodeClass = 'start'\r\n    } else if (isEndNode) {\r\n        nodeClass = 'end'\r\n    } else if (isWallNode) {\r\n        nodeClass = 'wall'\r\n    } else if (isPathNode) {\r\n        nodeClass = 'path'\r\n    } else if (isVisitedNode) {\r\n        nodeClass = 'visited'\r\n    } else if (isFrontierNode) {\r\n        nodeClass = 'frontier'\r\n    } else {\r\n        nodeClass = 'unvisited'\r\n    }\r\n\r\n    return (\r\n        <div className={`node ${nodeClass} unselectable`} onMouseOver={handleMouseOver}\r\n            onMouseUp={handleMouseUp} onMouseDown={handleMouseDown} >\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    return {\r\n        isVisitedNode: state.board.grid[ownProps.row][ownProps.col].isVisitedNode,\r\n        isWallNode: state.board.grid[ownProps.row][ownProps.col].isWallNode,\r\n        isStartNode: state.board.grid[ownProps.row][ownProps.col].isStartNode,\r\n        isEndNode: state.board.grid[ownProps.row][ownProps.col].isEndNode,\r\n        isPathNode: state.board.grid[ownProps.row][ownProps.col].isPathNode,\r\n        isFrontierNode: state.board.grid[ownProps.row][ownProps.col].isFrontierNode,\r\n        startNode: state.board.startNode,\r\n        endNode: state.board.endNode,\r\n        draggedNode: state.board.draggedNode,\r\n        algorithmSelected: state.algorithmSelected,\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        toggleWallNode: (row, col) => dispatch(toggleWallNode(row, col)),\r\n        setParentNode: (row, col) => dispatch(setParentNode(row, col)),\r\n        setDraggedNode: (row, col) => dispatch(setDraggedNode(row, col)),\r\n        clearDraggedNode: () => dispatch(clearDraggedNode()),\r\n        setStartNode: (row, col) => dispatch(setStartNode(row, col)),\r\n        setEndNode: (row, col) => dispatch(setEndNode(row, col)),\r\n        setStartMaskedNode: (row, col) => dispatch(setStartMaskedNode(row, col)),\r\n        setEndMaskedNode: (row, col) => dispatch(setEndMaskedNode(row, col)),\r\n        applyStartMaskedNode: (row, col) => dispatch(applyStartMaskedNode(row, col)),\r\n        applyEndMaskedNode: (row, col) => dispatch(applyEndMaskedNode(row, col)),\r\n        resetStartMaskedNode: (row, col) => dispatch(resetStartMaskedNode(row, col)),\r\n        resetEndMaskedNode: (row, col) => dispatch(resetEndMaskedNode(row, col)),\r\n        rerunAlgorithm: (algorithmSelected) => dispatch(rerunAlgorithm(algorithmSelected)),\r\n        clearPath: () => dispatch(clearPath()),\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node)\r\n","import React from 'react'\r\nimport { connect } from 'react-redux'\r\nimport { generateRowKey, generateCellKey } from '../utils/GridUtil'\r\nimport Node from './Node'\r\nimport '../css/Grid.css'\r\n\r\nfunction Grid(props) {\r\n    return (\r\n        <div className='grid'>\r\n            {props.grid.map((cellRow, row) => \r\n                <div className='grid-row' key={generateRowKey(row)}>\r\n                    {cellRow.map((cell, col) => \r\n                        <Node row={row} col={col} key={generateCellKey(row, col)} />\r\n                    )}\r\n                </div>\r\n            )}\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction mapStateToProps(state) {\r\n    return {\r\n        grid: state.board.grid\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid)\r\n","import React from 'react'\r\nimport '../css/Navbar.css'\r\n\r\n\r\nfunction Navbar({ algorithmStatus, algorithmSelected, runAlgorithm, generateWalls, clearBoard, clearPath,\r\n    readyAlgorithm, clearAlgorithmState, resetStartMaskedNode, resetEndMaskedNode, toggleShowCarousel }) {\r\n\r\n    const handleClickRun = () => {\r\n        runAlgorithm()\r\n    }\r\n\r\n    const handleClickGenerateWalls = () => {\r\n        generateWalls()\r\n    }\r\n\r\n    const handleClickClearPath = () => {\r\n        clearPath()\r\n        // discard the state saved by any algorithm pauses\r\n        clearAlgorithmState()\r\n        readyAlgorithm()\r\n    }\r\n\r\n    const handleClickClearBoard = () => {\r\n        clearBoard()\r\n        clearAlgorithmState()\r\n        readyAlgorithm()\r\n        resetStartMaskedNode()\r\n        resetEndMaskedNode()\r\n    }\r\n\r\n    let runButtonText;\r\n    let runButtonClass;\r\n    let runButtonDisabled = false\r\n    let generateWallsButtonDisabled = false\r\n    if (algorithmStatus === 'UNSELECTED') {\r\n        runButtonText = 'Select an Algorithm'\r\n        runButtonClass = 'unselected'\r\n        runButtonDisabled = true\r\n    } else if (algorithmStatus === 'READY') {\r\n        runButtonText = 'Run'\r\n        runButtonClass = 'run'\r\n    } else if (algorithmStatus === 'PAUSED') {\r\n        runButtonText = 'Resume'\r\n        runButtonClass = 'run'\r\n        generateWallsButtonDisabled = true\r\n    } else if (algorithmStatus === 'RUNNING') {\r\n        runButtonText = 'Pause'\r\n        runButtonClass = 'pause'\r\n        generateWallsButtonDisabled = true\r\n    } else {  // if 'COMPLETED'\r\n        runButtonText = 'Completed'\r\n        runButtonClass = 'completed'\r\n        runButtonDisabled = true\r\n        generateWallsButtonDisabled = true\r\n    }\r\n\r\n    return (\r\n        <nav className='navbar'>\r\n            <div className='navbar-list-container'>\r\n                <ul className='navbar-list'>\r\n                    <li className='navbar-item'>\r\n                        <button className={`navbar-button ${generateWallsButtonDisabled ? 'navbar-disabled-button' : 'navbar-normal-button'}`} \r\n                            onClick={handleClickGenerateWalls} disabled={generateWallsButtonDisabled}>Generate Walls</button>\r\n                    </li>\r\n                    <li className='navbar-item'>\r\n                        <button  className={`navbar-button ${generateWallsButtonDisabled ? 'navbar-disabled-button' : 'navbar-normal-button'}`}\r\n                            disabled={generateWallsButtonDisabled} onClick={toggleShowCarousel}>Select Algorithm</button>\r\n                    </li>\r\n                    <li className='navbar-item'>\r\n                        <button className={`navbar-button navbar-run-button ${runButtonClass}`} disabled={runButtonDisabled} onClick={handleClickRun}>\r\n                            {runButtonText}\r\n                        </button>\r\n                    </li>  \r\n                    <li className='navbar-item'>\r\n                        <button  className='navbar-button navbar-normal-button' onClick={handleClickClearPath}>Clear Path</button>\r\n                    </li>\r\n                    <li className='navbar-item'>\r\n                        <button  className='navbar-button navbar-normal-button' onClick={handleClickClearBoard}>Clear Board</button>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </nav>\r\n    )\r\n}\r\n\r\nexport default Navbar\r\n","import React from 'react'\r\nimport { connect } from 'react-redux'\r\nimport '../css/Statbar.css'\r\n\r\nfunction Statbar({ statistics }) {\r\n    return (\r\n        <div className='statbar'>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node start'></div>\r\n                    <span className='stat-description'>Start</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node end'></div>\r\n                    <span className='stat-description'>End</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node unvisited'></div>\r\n                    <span className='stat-description'>Unvisited</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numTotal - statistics.numVisited - statistics.numWall - statistics.numFrontier}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node visited'></div>\r\n                    <span className='stat-description'>Visited</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numVisited}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node frontier'></div>\r\n                    <span className='stat-description'>Frontier</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numFrontier}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node wall'></div>\r\n                    <span className='stat-description'>Wall</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numWall}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node path'></div>\r\n                    <span className='stat-description'>Path</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numPath}</span>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        statistics: state.board.statistics,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Statbar)\r\n","export default __webpack_public_path__ + \"static/media/BFS.569b2d36.gif\";","export default __webpack_public_path__ + \"static/media/A Star.a8baf9d5.gif\";","export default __webpack_public_path__ + \"static/media/Greedy.feab91fb.gif\";","export default __webpack_public_path__ + \"static/media/DFS.b219e317.gif\";","import React, { useState, useEffect, useRef } from 'react'\r\nimport '../css/Carousel.css'\r\nimport { FaArrowAltCircleLeft, FaArrowAltCircleRight } from \"react-icons/fa\";\r\nimport { AiFillCloseCircle } from \"react-icons/ai\";\r\nimport { BsFillCircleFill } from \"react-icons/bs\"\r\nimport { isAlgorithmUnselected } from '../utils/AlgorithmUtil';\r\nimport BFS_GIF from '../assets/images/BFS.gif'\r\nimport AStar_GIF from '../assets/images/A Star.gif'\r\nimport Greedy_GIF from '../assets/images/Greedy.gif'\r\nimport DFS_GIF from '../assets/images/DFS.gif'\r\n\r\nfunction Carousel({ toggleShowCarousel, setBFSAlgorithm, readyAlgorithm, setDFSAlgorithm, setAStarAlgorithm, setGreedyAlgorithm }) {\r\n    const algorithms = [{name: 'BFS', header: 'BFS Algorithm', dispatch: setBFSAlgorithm, gif: BFS_GIF, \r\n        description: \"It starts at the root and explores all of its children in the next level (neighbors) before moving to each of the root neighbors,\" + \r\n        \" and then, it explores the neighbors of the root neighbors, and so on. The algorithm uses a queue to perform the BFS.\"}, \r\n        {name: 'DFS', header: 'DFS Algorithm', dispatch: setDFSAlgorithm, gif: DFS_GIF,\r\n        description: \"It starts at the root and explores one of its childrens sub tree, and then moves to the next childs sub tree, and so on. \" + \r\n        \"It uses stack, or recursion to perform the DFS.\"},\r\n        {name: 'AStar', header: 'A Star Algorithm', dispatch: setAStarAlgorithm, gif: AStar_GIF,\r\n        description: \"A* is uses a combination of an educated guess (heuristic distance to the goal) and the distance from the root node \" + \r\n        \"to determine the estimated cost of traveling to the goal node using a particular node. Nodes with lower estimated cost are traversed first.\" + \r\n        \" The algorithm terminates when we find the goal node.\"}, \r\n        {name: 'Greedy', header: 'Greedy Algorithm', dispatch: setGreedyAlgorithm, gif: Greedy_GIF,\r\n        description: \"Greedy is an algorithm which makes a choice based on educated guesses (heuristics) at each stage. The node with shortest \" + \r\n        \"heuristic distance from the goal node will be explored next. Here we use the manhattan distance between a node and the goal node as the heuristic.\" + \r\n        \" It should be noted that the Greedy algorithm does not guarantee an optimal path.\"}]\r\n    const [ slideNum, setSlideNum ] = useState(0)\r\n    const wrapperRef = useRef(null)\r\n\r\n    // Close the Carousel when a click outside is detected\r\n    useEffect(() => {\r\n        function handleClickOutside(event) {\r\n            if (wrapperRef && !wrapperRef.current.contains(event.target))\r\n                toggleShowCarousel()\r\n        }\r\n        // Bind the event listener\r\n        document.addEventListener('mousedown', handleClickOutside)\r\n        return (() => {\r\n            // Unbind the event listener on clean up\r\n            document.removeEventListener('mousedown', handleClickOutside)\r\n        })\r\n        \r\n    }, [wrapperRef, toggleShowCarousel])\r\n\r\n    // Custom modulo function. The default Javascript modulo operator that gives -3 % 4 = -3. Instead, we want it to be 1\r\n    const mod = (m, n) => {\r\n        return ((m % n) + n) % n\r\n    }\r\n\r\n    const handleClickSelect = (slideNum) => {\r\n        algorithms[slideNum].dispatch()\r\n        toggleShowCarousel()\r\n        if (isAlgorithmUnselected())\r\n            readyAlgorithm()\r\n    }\r\n\r\n    const handleClickLeft = (event) => {\r\n        setSlideNum(mod(slideNum - 1, algorithms.length))\r\n    }\r\n\r\n    const handleClickRight = (event) => {\r\n        setSlideNum(mod(slideNum + 1, algorithms.length))\r\n    }\r\n\r\n    return (\r\n        <div className='carousel-container'>\r\n            <div className='carousel' ref={wrapperRef}>\r\n                <h1>{ algorithms[slideNum].header }</h1>\r\n                <AiFillCloseCircle className='window-close-icon' onClick={toggleShowCarousel} />\r\n                <div className='carousel-upper-mid'>\r\n                    <div className='carousel-arrow-container'>\r\n                        <FaArrowAltCircleLeft className='arrow-circle-icon' onClick={handleClickLeft} />\r\n                    </div>\r\n                    <img src={algorithms[slideNum].gif} alt={algorithms[slideNum].name} />\r\n                    <div className='carousel-arrow-container'>\r\n                        <FaArrowAltCircleRight className='arrow-circle-icon' onClick={handleClickRight} />\r\n                    </div>\r\n                </div>\r\n                <div className='carousel-lower-mid'>\r\n                    <p className='algorithm-description'>\r\n                        {algorithms[slideNum].description}\r\n                    </p>\r\n                </div>\r\n                <div className='carousel-bottom'>\r\n                    <button className='carousel-select-button' onClick={() => handleClickSelect(slideNum)}>Select</button>\r\n                    <div className='carousel-navigation'>\r\n                        <BsFillCircleFill className={`carousel-navigation-button ${slideNum === 0 ? 'carousel-navigation-button-selected' : ''}`} onClick={() => setSlideNum(0)} />\r\n                        <BsFillCircleFill className={`carousel-navigation-button ${slideNum === 1 ? 'carousel-navigation-button-selected' : ''}`} onClick={() => setSlideNum(1)} />\r\n                        <BsFillCircleFill className={`carousel-navigation-button ${slideNum === 2 ? 'carousel-navigation-button-selected' : ''}`} onClick={() => setSlideNum(2)} />\r\n                        <BsFillCircleFill className={`carousel-navigation-button ${slideNum === 3 ? 'carousel-navigation-button-selected' : ''}`} onClick={() => setSlideNum(3)} />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Carousel\r\n","import React, { useState } from 'react'\r\nimport Grid from './Grid'\r\nimport Navbar from './Navbar'\r\nimport Statbar from './Statbar'\r\nimport Carousel from './Carousel'\r\nimport '../css/Menu.css'\r\nimport { setBFSAlgorithm, toggleVisitedNode, toggleFrontierNode,\r\n    setAlgorithmState, readyAlgorithm, runAlgorithm, pauseAlgorithm, completeAlgorithm,\r\n    togglePathNode, setParentNode, generateWalls, clearBoard, clearPath, clearAlgorithmState, \r\n    resetStartMaskedNode, resetEndMaskedNode, setDFSAlgorithm, setAStarAlgorithm, setGreedyAlgorithm,\r\n    setEstimateValues } from '../actions'\r\nimport { connect } from 'react-redux'\r\nimport { runBFS } from '../utils/Algorithms/BFS'\r\nimport { runDFS } from '../utils/Algorithms/DFS'\r\nimport { runAStar } from '../utils/Algorithms/AStar'\r\nimport { isAlgorithmRunning, isAlgorithmCompleted, isAlgorithmReady } from '../utils/AlgorithmUtil'\r\nimport { runGreedy } from '../utils/Algorithms/Greedy'\r\n\r\nfunction Menu(props) {\r\n\r\n    const [ showCarousel, setShowCarousel ] = useState(false)\r\n\r\n    const runAlgorithm = async () => {\r\n\r\n        if (isAlgorithmRunning()) {\r\n            props.pauseAlgorithm()\r\n            return\r\n        }\r\n        \r\n        props.runAlgorithm()  // Change algorithm status to running\r\n        \r\n        let state;\r\n        switch (props.algorithmSelected) {\r\n            case 'BFS':\r\n                state = await runBFS(props.algorithmState, props.grid, props.startNode, props.endNode, props.toggleVisitedNode, \r\n                    props.toggleFrontierNode, props.togglePathNode, props.completeAlgorithm, props.setParentNode)\r\n                break\r\n            case 'DFS':\r\n                state = await runDFS(props.algorithmState, props.grid, props.startNode, props.endNode, props.toggleVisitedNode, \r\n                    props.toggleFrontierNode, props.togglePathNode, props.completeAlgorithm, props.setParentNode)\r\n                break\r\n            case 'ASTAR':\r\n                state = await runAStar(props.algorithmState, props.grid, props.startNode, props.endNode, props.toggleVisitedNode, \r\n                    props.toggleFrontierNode, props.togglePathNode, props.completeAlgorithm, props.setParentNode, props.setEstimateValues)\r\n                break\r\n            case 'GREEDY':\r\n                state = await runGreedy(props.algorithmState, props.grid, props.startNode, props.endNode, props.toggleVisitedNode, \r\n                    props.toggleFrontierNode, props.togglePathNode, props.completeAlgorithm, props.setParentNode, props.setEstimateValues)\r\n                break\r\n            default:\r\n                break\r\n        }\r\n\r\n        // We have to clear the algorithm state if it is completed or sent back to the ready state from the running state\r\n        // this happens when we click clearBoard or clearPath buttons while the algorithm is still running\r\n        if (isAlgorithmCompleted() || isAlgorithmReady()) {\r\n            props.clearAlgorithmState()\r\n        } else {\r\n            props.setAlgorithmState(state)\r\n        }\r\n        \r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <Navbar runAlgorithm={runAlgorithm} \r\n                algorithmStatus={props.algorithmStatus}\r\n                algorithmSelected={props.algorithmSelected}\r\n                generateWalls={props.generateWalls}\r\n                clearBoard={props.clearBoard}\r\n                clearPath={props.clearPath}\r\n                readyAlgorithm={props.readyAlgorithm}\r\n                clearAlgorithmState={props.clearAlgorithmState}\r\n                resetStartMaskedNode={props.resetStartMaskedNode}\r\n                resetEndMaskedNode={props.resetEndMaskedNode}\r\n                toggleShowCarousel={() => setShowCarousel(!showCarousel)} />\r\n            <div className='grid-container'>\r\n                <Grid />\r\n            </div>\r\n            <div className='statbar-container'>\r\n                <Statbar />\r\n            </div>\r\n            {showCarousel && <Carousel toggleShowCarousel={() => setShowCarousel(!showCarousel)} \r\n                setBFSAlgorithm={props.setBFSAlgorithm} readyAlgorithm={props.readyAlgorithm} setDFSAlgorithm={props.setDFSAlgorithm}\r\n                setAStarAlgorithm={props.setAStarAlgorithm} setGreedyAlgorithm={props.setGreedyAlgorithm} />}\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        setBFSAlgorithm: () => dispatch(setBFSAlgorithm()),\r\n        setDFSAlgorithm: () => dispatch(setDFSAlgorithm()),\r\n        setAStarAlgorithm: () => dispatch(setAStarAlgorithm()),\r\n        setGreedyAlgorithm: () => dispatch(setGreedyAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        setAlgorithmState: (state) => dispatch(setAlgorithmState(state)),\r\n        clearAlgorithmState: () => dispatch(clearAlgorithmState()),\r\n        readyAlgorithm: () => dispatch(readyAlgorithm()),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        setParentNode: (row, col, parent) => dispatch(setParentNode(row, col, parent)),\r\n        generateWalls: () => dispatch(generateWalls()),\r\n        clearBoard: () => dispatch(clearBoard()),\r\n        clearPath: () => dispatch(clearPath()),\r\n        resetStartMaskedNode: () => dispatch(resetStartMaskedNode()),\r\n        resetEndMaskedNode: () => dispatch(resetEndMaskedNode()),\r\n        setEstimateValues: (row, col, f, g, h) => dispatch(setEstimateValues(row, col, f, g, h)),\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        grid: state.board.grid,\r\n        algorithmSelected: state.algorithmSelected,\r\n        startNode: state.board.startNode,\r\n        endNode: state.board.endNode,\r\n        algorithmState: state.algorithmState,\r\n        algorithmStatus: state.algorithmStatus,\r\n        statistics: state.board.statistics,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu)\r\n","import '../css/App.css';\nimport Menu from './Menu';\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Menu />\n    </div>\n  );\n}\n\nexport default App;\n","import { combineReducers } from \"redux\"\r\nimport { generateEmptyGrid, setEndNode, setFrontierNode, setPathNode, setStartNode, setVisitedNode, setWallNode,\r\n    setParentNode, generateWalls, clearBoard, clearPath, initializeStatistics, Node, applyMaskedNode, generateRerunAlgorithmGrid, \r\n    calculateMaskedStatistic, setEstimateValues } from \"../utils/GridUtil\"\r\nimport { SET_BFS_ALGORITHM, SET_ASTAR_ALGORITHM, SET_DFS_ALGORITHM, SET_GREEDY_ALGORITHM,\r\n    TOGGLE_FRONTIER_NODE, TOGGLE_PATH_NODE, TOGGLE_VISITED_NODE, TOGGLE_WALL_NODE,\r\n    SET_ALGORITHM_STATE, CLEAR_ALGORITHM_STATE, SET_START_NODE, SET_END_NODE, READY_ALGORITHM, COMPLETE_ALGORITHM,\r\n    PAUSE_ALGORITHM, RUN_ALGORITHM, SET_PARENT_NODE, GENERATE_WALLS, CLEAR_BOARD, CLEAR_PATH, SET_DRAGGED_NODE, \r\n    CLEAR_DRAGGED_NODE, SET_START_MASKED_NODE, APPLY_START_MASKED_NODE, RERUN_ALGORITHM, RESET_START_MASKED_NODE,\r\n    SET_END_MASKED_NODE, APPLY_END_MASKED_NODE, RESET_END_MASKED_NODE, SET_ESTIMATE_VALUES } from '../actions'\r\n\r\nconst numRows = 20  // Grid Dimensions\r\nconst numCols = 50\r\nconst start = {row: 9, col: 15 }  // Start Node\r\nconst end = { row: 9, col: 35 }  // End Node\r\n\r\nfunction board(state = { grid: generateEmptyGrid(numRows, numCols, start, end), statistics: initializeStatistics(numRows, numCols), \r\n        draggedNode: null, startMaskedNode: new Node(), endMaskedNode: new Node(), startNode: start, endNode: end }, action) {\r\n    switch(action.type) {\r\n        case TOGGLE_VISITED_NODE: {\r\n            const { grid, statistics } = setVisitedNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case TOGGLE_WALL_NODE: {\r\n            const { grid, statistics } = setWallNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case TOGGLE_FRONTIER_NODE: {\r\n            const { grid, statistics } = setFrontierNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case TOGGLE_PATH_NODE: {\r\n            const { grid, statistics } = setPathNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case SET_START_NODE:\r\n            return {\r\n                ...state,\r\n                grid: setStartNode(state.grid, action.payload),\r\n                startNode: { row: action.payload.row, col: action.payload.col }\r\n            }\r\n        case SET_END_NODE:\r\n            return {\r\n                ...state,\r\n                grid: setEndNode(state.grid, action.payload),\r\n                endNode: { row: action.payload.row, col: action.payload.col }\r\n            }\r\n        case SET_PARENT_NODE:\r\n            return {\r\n                ...state,\r\n                grid: setParentNode(state.grid, action.payload)\r\n            }\r\n        case GENERATE_WALLS: {\r\n            const { grid, statistics } = generateWalls(state.grid, state.statistics)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case CLEAR_BOARD: {\r\n            const { grid, statistics } = clearBoard(state.grid, state.startNode, state.endNode)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case CLEAR_PATH: {\r\n            const { grid, statistics } = clearPath(state.grid, state.statistics)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case SET_DRAGGED_NODE:\r\n            return {\r\n                ...state,\r\n                draggedNode: {\r\n                    ...state.grid[action.payload.row][action.payload.col],\r\n                    row: action.payload.row,\r\n                    col: action.payload.col,\r\n                }\r\n            }\r\n        case CLEAR_DRAGGED_NODE:\r\n            return {\r\n                ...state,\r\n                draggedNode: null\r\n            }\r\n        case SET_START_MASKED_NODE: {\r\n            const { statistics } = calculateMaskedStatistic(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                statistics,\r\n                startMaskedNode: {\r\n                    ...state.grid[action.payload.row][action.payload.col]\r\n                }\r\n            }\r\n        }\r\n        case APPLY_START_MASKED_NODE: {\r\n            const { grid, statistics } = applyMaskedNode(state.grid, state.statistics, action.payload, state.startMaskedNode)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics \r\n            }\r\n        }\r\n        case RESET_START_MASKED_NODE: \r\n            return {\r\n                ...state,\r\n                startMaskedNode: new Node()\r\n            }\r\n        case SET_END_MASKED_NODE: {\r\n            const { statistics } = calculateMaskedStatistic(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                statistics,\r\n                endMaskedNode: {\r\n                    ...state.grid[action.payload.row][action.payload.col]\r\n                }\r\n            }\r\n        }\r\n        case APPLY_END_MASKED_NODE: {\r\n            const { grid, statistics } = applyMaskedNode(state.grid, state.statistics, action.payload, state.endMaskedNode)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics \r\n            }\r\n        }\r\n        case RESET_END_MASKED_NODE: \r\n            return {\r\n                ...state,\r\n                endMaskedNode: new Node()\r\n            }\r\n        case RERUN_ALGORITHM: {\r\n            const { grid, statistics } = generateRerunAlgorithmGrid(state.grid, state.startNode, \r\n                state.endNode, action.payload.algorithmSelected)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case SET_ESTIMATE_VALUES: \r\n            return {\r\n                ...state,\r\n                grid: setEstimateValues(state.grid, action.payload)\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n} \r\n\r\nfunction algorithmStatus(state = 'UNSELECTED', action) {\r\n    switch(action.type) {\r\n        case READY_ALGORITHM:\r\n            return 'READY';\r\n        case RUN_ALGORITHM:\r\n            return 'RUNNING';\r\n        case PAUSE_ALGORITHM:\r\n            return 'PAUSED';\r\n        case COMPLETE_ALGORITHM:\r\n            return 'COMPLETED';\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nfunction algorithmSelected(state = null, action) {  // we set initial to BFS for now to test\r\n    switch(action.type) {\r\n        case SET_BFS_ALGORITHM:\r\n            return 'BFS';\r\n        case SET_ASTAR_ALGORITHM:\r\n            return 'ASTAR';\r\n        case SET_DFS_ALGORITHM:\r\n            return 'DFS';\r\n        case SET_GREEDY_ALGORITHM:\r\n            return 'GREEDY';\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nfunction algorithmState(state = null, action) {  \r\n    switch(action.type) {\r\n        case SET_ALGORITHM_STATE:\r\n            return action.payload;\r\n        case CLEAR_ALGORITHM_STATE:\r\n            return null;\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nconst reducer = combineReducers({\r\n    board,\r\n    algorithmStatus,\r\n    algorithmSelected,\r\n    algorithmState\r\n})\r\n\r\nexport default reducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux';\nimport reducer from './reducers'\n\nconst store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__())\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nexport default store\n"],"sourceRoot":""}