{"version":3,"sources":["utils/AlgorithmUtil.js","utils/Algorithms/BFS.js","utils/GridUtil.js","actions/index.js","components/Node.js","components/Grid.js","components/Navbar.js","components/Statbar.js","components/Menu.js","components/App.js","reducers/index.js","index.js"],"names":["isAlgorithmRunning","store","getState","algorithmStatus","isAlgorithmCompleted","nodeEquals","node_1","node_2","getNeighbors","node","neighbors","Array","dy","dx","i","length","push","shouldEnqueueNode","grid","m","n","j","isVisitedNode","isWallNode","isFrontierNode","tracePath","endNode","togglePathNode","a","stack","buckets","Stack","parent","isEmpty","pop","sleep","setPath","isPathNode","duration","Promise","resolve","setTimeout","runBFS","queue","startNode","toggleVisitedNode","toggleFrontierNode","completeAlgorithm","setParentNode","Queue","enqueue","currNode","dequeue","neighbor","slice","Node","this","isStartNode","isEndNode","Statistic","numTotal","numVisited","numFrontier","numWall","numPath","generateEmptyGrid","numRows","numCols","calculateStatistics","statistics","console","log","generateRerunAlgorithmGrid","algorithmSelected","rerunBFS","setVisitedNode","row","col","setWallNode","setFrontierNode","setPathNode","setStartNode","initializeStartNode","setEndNode","initializeEndNode","applyMaskedNode","maskedNode","calculateMaskedStatistic","newMaskedNode","generateWalls","Math","random","clearBoard","initializeStatistics","clearPath","SET_BFS_ALGORITHM","SET_DFS_ALGORITHM","SET_ASTAR_ALGORITHM","SET_GREEDY_ALGORITHM","TOGGLE_VISITED_NODE","TOGGLE_FRONTIER_NODE","TOGGLE_WALL_NODE","TOGGLE_PATH_NODE","SET_ALGORITHM_STATE","CLEAR_ALGORITHM_STATE","SET_START_NODE","SET_END_NODE","RUN_ALGORITHM","READY_ALGORITHM","PAUSE_ALGORITHM","COMPLETE_ALGORITHM","SET_PARENT_NODE","GENERATE_WALLS","CLEAR_BOARD","CLEAR_PATH","SET_DRAGGED_NODE","CLEAR_DRAGGED_NODE","SET_START_MASKED_NODE","APPLY_START_MASKED_NODE","RERUN_ALGORITHM","RESET_START_MASKED_NODE","SET_END_MASKED_NODE","APPLY_END_MASKED_NODE","RESET_END_MASKED_NODE","type","payload","resetStartMaskedNode","resetEndMaskedNode","connect","state","ownProps","board","draggedNode","dispatch","toggleWallNode","setDraggedNode","clearDraggedNode","setStartMaskedNode","setEndMaskedNode","applyStartMaskedNode","applyEndMaskedNode","rerunAlgorithm","nodeClass","className","onMouseOver","onMouseUp","onMouseDown","props","map","cellRow","cell","toString","generateCellKey","generateRowKey","Navbar","runButtonText","runButtonClass","runAlgorithm","readyAlgorithm","clearAlgorithmState","runButtonDisabled","onClick","disabled","algorithmState","setBFSAlgorithm","setAlgorithmState","pauseAlgorithm","App","start","end","reducer","combineReducers","startMaskedNode","endMaskedNode","action","createStore","window","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2225dffb.chunk.js","sourcesContent":["import store from \"../\"\r\nimport buckets from 'buckets-js'\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    return store.getState().algorithmStatus === 'RUNNING'\r\n}\r\n\r\nexport const isAlgorithmCompleted = () => {\r\n    return store.getState().algorithmStatus === 'COMPLETED'\r\n}\r\n\r\nexport const isAlgorithmReady = () => {\r\n    return store.getState().algorithmStatus === 'READY'\r\n}\r\n\r\nexport const nodeEquals = (node_1, node_2) => {\r\n    return node_1[0] === node_2[0] && node_1[1] === node_2[1]\r\n}\r\n\r\nexport const getNeighbors = (node) => {\r\n    const neighbors = new Array(0)\r\n    const dy = [0, 0, -1, 1]  // directions of i\r\n    const dx = [1, -1, 0, 0]  // directions of j\r\n    for (let i = 0; i < dy.length; i++) {\r\n        neighbors.push([node[0] + dy[i], node[1] + dx[i]])\r\n    }\r\n    return neighbors\r\n}\r\n\r\n// Enqueue the Node only if it is within the range of the grid, not visited, not a frontier and not a wall node\r\nexport const shouldEnqueueNode = (node, grid) => {\r\n    const m = grid.length\r\n    const n = grid[0].length\r\n    const i = node[0]\r\n    const j = node[1]\r\n    return i >= 0 && i < m && j >= 0 && j < n && !grid[i][j].isVisitedNode && !grid[i][j].isWallNode && !grid[i][j].isFrontierNode\r\n}\r\n\r\nexport const tracePath = async (endNode, grid, togglePathNode) => {\r\n    let node = endNode\r\n    const stack = buckets.Stack() \r\n    while (node != null) {\r\n        stack.push(node)\r\n        node = grid[node[0]][node[1]].parent\r\n    }\r\n    while (!stack.isEmpty()) {\r\n        node = stack.pop()\r\n        togglePathNode(node[0], node[1])\r\n        await sleep(40)\r\n    }\r\n}\r\n\r\n// This sets the path immediately\r\n// without having the trace animation (no intervals between each path node animation)\r\nexport const setPath = (endNode, grid) => {\r\n    let node = endNode\r\n    const stack = buckets.Stack() \r\n    while (node != null) {\r\n        stack.push(node)\r\n        node = grid[node[0]][node[1]].parent\r\n    }\r\n    while (!stack.isEmpty()) {\r\n        node = stack.pop()\r\n        grid[node[0]][node[1]].isPathNode = true\r\n    }\r\n}\r\n\r\nexport const sleep = (duration) => {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, duration)\r\n    })\r\n}","import { isAlgorithmRunning, nodeEquals, shouldEnqueueNode, getNeighbors, \r\n    sleep, tracePath, setPath } from '../AlgorithmUtil'\r\nimport buckets from 'buckets-js'\r\n\r\nexport const runBFS = async (queue, grid, startNode, endNode, toggleVisitedNode, toggleFrontierNode,\r\n    togglePathNode, completeAlgorithm, setParentNode) => {\r\n        \r\n    // While the algorithm has not been completed or paused\r\n    while (isAlgorithmRunning()) {\r\n        \r\n        // Create a new queue if the current algorithm state is empty; this is the first iteration\r\n        if (!queue) {\r\n            queue = buckets.Queue()\r\n            queue.enqueue(startNode)\r\n        }\r\n\r\n        if (queue.isEmpty()) {  // No path was found\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        // Perform one iteration of BFS\r\n        const currNode = queue.dequeue()\r\n        toggleVisitedNode(currNode[0], currNode[1])\r\n        toggleFrontierNode(currNode[0], currNode[1])  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            await tracePath(endNode, grid, togglePathNode)\r\n            completeAlgorithm()\r\n            return\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldEnqueueNode(neighbor, grid)) {\r\n                toggleFrontierNode(neighbor[0], neighbor[1])\r\n                setParentNode(neighbor[0], neighbor[1], currNode.slice())\r\n                queue.enqueue(neighbor)\r\n            }\r\n        }\r\n\r\n        // Timeout ensures that the animation has enough time to render fully\r\n        await sleep(0)\r\n\r\n    }\r\n\r\n    return queue\r\n\r\n}\r\n\r\nexport const rerunBFS = (grid, startNode, endNode) => {\r\n    const queue = buckets.Queue()\r\n    queue.enqueue(startNode)\r\n    while (!queue.isEmpty()) {\r\n        const currNode = queue.dequeue()\r\n        grid[currNode[0]][currNode[1]].isVisitedNode = true\r\n        grid[currNode[0]][currNode[1]].isFrontierNode = false  // this node is no longer a frontier node\r\n\r\n        if (nodeEquals(endNode, currNode)) {\r\n            setPath(endNode, grid)\r\n            break\r\n        }\r\n\r\n        const neighbors = getNeighbors(currNode)\r\n        for (const neighbor of neighbors) {\r\n            if (shouldEnqueueNode(neighbor, grid)) {\r\n                grid[neighbor[0]][neighbor[1]].isFrontierNode = true\r\n                grid[neighbor[0]][neighbor[1]].parent = currNode.slice()\r\n                queue.enqueue(neighbor)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return grid\r\n}","import { rerunBFS } from \"./Algorithms/BFS\"\r\n\r\n// Node constructor\r\nexport function Node() {\r\n    this.isStartNode = false\r\n    this.isEndNode = false\r\n    this.isWallNode = false\r\n    this.isFrontierNode = false\r\n    this.isVisitedNode = false\r\n    this.isPathNode = false\r\n    this.parent = null\r\n}\r\n\r\nexport const initializeStartNode = () => {\r\n    const node = new Node()\r\n    node.isStartNode = true\r\n    return node\r\n}\r\n\r\nexport const initializeEndNode = () => {\r\n    const node = new Node()\r\n    node.isEndNode = true\r\n    return node\r\n}\r\n\r\nfunction Statistic(numTotal) {\r\n    this.numTotal = numTotal\r\n    this.numVisited = 0\r\n    this.numFrontier = 0\r\n    this.numWall = 0\r\n    this.numPath = 0\r\n}\r\n\r\n// Key generators for React Grid mapping to rows and cells\r\nexport const generateRowKey = (row) => {\r\n    return row.toString()\r\n}\r\n\r\nexport const generateCellKey = (row, col) => {\r\n    return row.toString() + '#' + col.toString()\r\n}\r\n\r\n// Utilities for generating grids\r\nexport const generateEmptyGrid = (numRows, numCols, startNode, endNode) => {\r\n    const grid = new Array(0)\r\n    for (let i = 0; i < numRows; i++) {\r\n        grid.push(new Array(0))\r\n        for (let j = 0; j < numCols; j++) {\r\n            grid[i].push(new Node())\r\n        }\r\n    }\r\n    grid[startNode[0]][startNode[1]].isStartNode = true\r\n    grid[endNode[0]][endNode[1]].isEndNode = true\r\n    return grid\r\n}\r\n\r\nconst calculateStatistics = (grid) => {\r\n    const numRows = grid.length\r\n    const numCols = grid[0].length\r\n    const statistics = new Statistic(numRows * numCols)\r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            statistics.numWall += grid[i][j].isWallNode ? 1 : 0\r\n            statistics.numVisited += grid[i][j].isVisitedNode ? 1 : 0\r\n            statistics.numFrontier += grid[i][j].isFrontierNode ? 1 : 0\r\n            statistics.numPath += grid[i][j].isPathNode ? 1 : 0\r\n        }\r\n    }\r\n    console.log(statistics)\r\n    return statistics\r\n}\r\n\r\nexport const generateRerunAlgorithmGrid = (grid, startNode, endNode, algorithmSelected) => {\r\n    grid = grid.slice()\r\n    switch (algorithmSelected) {\r\n        case 'BFS':\r\n            grid = rerunBFS(grid, startNode, endNode)\r\n            break\r\n        case 'DFS':\r\n            break\r\n        case 'ASTAR':\r\n            break\r\n        case 'GREEDY':\r\n            break\r\n        default:\r\n            break\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: calculateStatistics(grid) \r\n    }\r\n}\r\n\r\nexport const setVisitedNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isVisitedNode = !node.isVisitedNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numVisited: node.isVisitedNode ? statistics.numVisited + 1 : statistics.numVisited - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setWallNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isWallNode = !node.isWallNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numWall: node.isWallNode ? statistics.numWall + 1 : statistics.numWall - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setFrontierNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isFrontierNode = !node.isFrontierNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numFrontier: node.isFrontierNode ? statistics.numFrontier + 1 : statistics.numFrontier - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setPathNode = (grid, statistics, {row, col}) => {\r\n    grid = grid.slice()\r\n    const node = grid[row][col]\r\n    node.isPathNode = !node.isPathNode;\r\n    return {\r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numPath: node.isPathNode ? statistics.numPath + 1 : statistics.numPath - 1\r\n        }\r\n    }\r\n}\r\n\r\nexport const setStartNode = (grid, {row, col}) => {\r\n    grid = grid.slice()\r\n    grid[row][col] = initializeStartNode()\r\n    return grid\r\n}\r\n\r\nexport const setEndNode = (grid, {row, col}) => {\r\n    grid = grid.slice()\r\n    grid[row][col] = initializeEndNode()\r\n    return grid\r\n}\r\n\r\nexport const setParentNode = (grid, {row, col, parent}) => {\r\n    grid = grid.slice()\r\n    grid[row][col].parent = parent;\r\n    return grid\r\n}\r\n\r\nexport const applyMaskedNode = (grid, statistics, {row, col}, maskedNode) => {\r\n    grid = grid.slice()\r\n    \r\n    grid[row][col] = maskedNode;\r\n    return { \r\n        grid,\r\n        statistics: {\r\n            ...statistics,\r\n            numWall: statistics.numWall + (maskedNode.isWallNode ? 1 : 0),\r\n        }\r\n    }\r\n}\r\n\r\nexport const calculateMaskedStatistic = (grid, statistics, {row, col}) => {\r\n    const newMaskedNode = grid[row][col]\r\n    return {\r\n        statistics: {\r\n            ...statistics,\r\n            numWall: statistics.numWall - (newMaskedNode.isWallNode ? 1 : 0),\r\n        }\r\n    }\r\n}\r\n\r\nexport const generateWalls = (grid, statistics) => {\r\n    grid = grid.slice()\r\n    const p = 0.3  // probability that a node becomes a wall node \r\n    let numWall = 0\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const node = grid[i][j]\r\n            if (!node.isStartNode && !node.isEndNode && Math.random() <= p) {\r\n                node.isWallNode = true\r\n                numWall++\r\n            } else {\r\n                node.isWallNode = false\r\n            }\r\n        }\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: {\r\n            ...statistics,\r\n            numWall\r\n        }\r\n    }\r\n}\r\n\r\nexport const clearBoard = (grid, statistics) => {\r\n    grid = grid.slice()\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const node = grid[i][j]\r\n            if (!node.isStartNode && !node.isEndNode) {\r\n                grid[i][j] = new Node()\r\n            } else {\r\n                node.isWallNode = false\r\n                node.isVisitedNode = false\r\n                node.isPathNode = false\r\n            }\r\n        }\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: initializeStatistics(grid.length, grid[0].length)\r\n    }\r\n}\r\n\r\nexport const clearPath = (grid, statistics) => {\r\n    grid = grid.slice()\r\n    for (let i = 0; i < grid.length; i++) {\r\n        for (let j = 0; j < grid[0].length; j++) {\r\n            const node = grid[i][j]\r\n            node.isPathNode = false\r\n            node.isVisitedNode = false\r\n            node.isFrontierNode = false\r\n        }\r\n    }\r\n    return { \r\n        grid, \r\n        statistics: {\r\n            ...statistics,\r\n            numPath: 0,\r\n            numFrontier: 0,\r\n            numVisited: 0\r\n        }\r\n    }\r\n}\r\n\r\n// Utilities for generating statistics\r\nexport const initializeStatistics = (numRows, numCols) => {\r\n    return new Statistic(numRows * numCols)\r\n}","// create and export types for our actions\r\nexport const SET_BFS_ALGORITHM = \"SET_BFS_ALGORITHM\"\r\nexport const SET_DFS_ALGORITHM = \"SET_DFS_ALGORITHM\"\r\nexport const SET_ASTAR_ALGORITHM = \"SET_ASTAR_ALGORITHM\"\r\nexport const SET_GREEDY_ALGORITHM = \"SET_GREEDY_ALGORITHM\"\r\nexport const TOGGLE_VISITED_NODE = \"TOGGLE_VISITED_NODE\"\r\nexport const TOGGLE_FRONTIER_NODE = \"TOGGLE_FRONTIER_NODE\"\r\nexport const TOGGLE_WALL_NODE = \"TOGGLE_WALL_NODE\"\r\nexport const TOGGLE_PATH_NODE = \"TOGGLE_PATH_NODE\"\r\nexport const SET_ALGORITHM_STATE = \"SET_ALGORITHM_STATE\"\r\nexport const CLEAR_ALGORITHM_STATE = \"CLEAR_ALGORITHM_STATE\"\r\nexport const SET_START_NODE = \"SET_START_NODE\"\r\nexport const SET_END_NODE = \"SET_END_NODE\"\r\nexport const RUN_ALGORITHM = \"RUN_ALGORITHM\"\r\nexport const READY_ALGORITHM = \"READY_ALGORITHM\"\r\nexport const PAUSE_ALGORITHM = \"PAUSE_ALGORITHM\"\r\nexport const COMPLETE_ALGORITHM = \"COMPLETE_ALGORITHM\" \r\nexport const SET_PARENT_NODE = \"SET_PARENT_NODE\"\r\nexport const GENERATE_WALLS = \"GENERATE_WALLS\"\r\nexport const CLEAR_BOARD = \"CLEAR_BOARD\"\r\nexport const CLEAR_PATH = \"CLEAR_PATH\"\r\nexport const SET_DRAGGED_NODE = \"SET_DRAGGED_NODE\"\r\nexport const CLEAR_DRAGGED_NODE = \"CLEAR_DRAGGED_NODE\"\r\nexport const SET_START_MASKED_NODE = \"SET_START_MASKED_NODE\"\r\nexport const APPLY_START_MASKED_NODE = \"APPLY_START_MASKED_NODE\"\r\nexport const RERUN_ALGORITHM = \"RERUN_ALGORITHM\"\r\nexport const RESET_START_MASKED_NODE = \"RESET_START_MASKED_NODE\"\r\nexport const SET_END_MASKED_NODE = \"SET_END_MASKED_NODE\"\r\nexport const APPLY_END_MASKED_NODE = \"APPLY_END_MASKED_NODE\"\r\nexport const RESET_END_MASKED_NODE = \"RESET_END_MASKED_NODE\"\r\n\r\n\r\n// action creators for grid state\r\nexport const rerunAlgorithm = (algorithmSelected) => {\r\n    return {\r\n        type: RERUN_ALGORITHM,\r\n        payload: { algorithmSelected }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_VISITED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_FRONTIER_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_WALL_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: TOGGLE_PATH_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setParentNode = (row, col, parent) => {\r\n    return {\r\n        type: SET_PARENT_NODE,\r\n        payload: {row, col, parent}\r\n    }\r\n}\r\n\r\nexport const generateWalls = () => {\r\n    return {\r\n        type: GENERATE_WALLS\r\n    }\r\n}\r\n\r\nexport const clearBoard = () => {\r\n    return {\r\n        type: CLEAR_BOARD\r\n    }\r\n}\r\n\r\nexport const clearPath = () => {\r\n    return {\r\n        type: CLEAR_PATH\r\n    }\r\n}\r\n\r\n// action creators for algorithm state\r\n\r\nexport const runAlgorithm = () => {\r\n    return {\r\n        type: RUN_ALGORITHM,\r\n    }\r\n};\r\n\r\nexport const readyAlgorithm = () => {\r\n    return {\r\n        type: READY_ALGORITHM,\r\n    }\r\n};\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return {\r\n        type: PAUSE_ALGORITHM,\r\n    }\r\n};\r\n\r\nexport const completeAlgorithm = () => {\r\n    return {\r\n        type: COMPLETE_ALGORITHM,\r\n    }\r\n};\r\n\r\n\r\nexport const setBFSAlgorithm = () => {\r\n    return {\r\n        type: SET_BFS_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setDFSAlgorithm = () => {\r\n    return {\r\n        type: SET_DFS_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setAStarAlgorithm = () => {\r\n    return {\r\n        type: SET_ASTAR_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setGreedyAlgorithm = () => {\r\n    return {\r\n        type: SET_GREEDY_ALGORITHM\r\n    }\r\n}\r\n\r\nexport const setAlgorithmState = (algorithmState) => {\r\n    return {\r\n        type: SET_ALGORITHM_STATE,\r\n        payload: algorithmState\r\n    }\r\n}\r\n\r\nexport const clearAlgorithmState = () => {\r\n    return {\r\n        type: CLEAR_ALGORITHM_STATE\r\n    }\r\n}\r\n\r\n// action creators for tracking nodes\r\nexport const setStartNode = (row, col) => {\r\n    return {\r\n        type: SET_START_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setEndNode = (row, col) => {\r\n    return {\r\n        type: SET_END_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setDraggedNode = (row, col) => {\r\n    return {\r\n        type: SET_DRAGGED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const clearDraggedNode = (row, col) => {\r\n    return {\r\n        type: CLEAR_DRAGGED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setStartMaskedNode = (row, col) => {\r\n    return {\r\n        type: SET_START_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\n\r\nexport const applyStartMaskedNode = (row, col) => {\r\n    return {\r\n        type: APPLY_START_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const setEndMaskedNode = (row, col) => {\r\n    return {\r\n        type: SET_END_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\n\r\nexport const applyEndMaskedNode = (row, col) => {\r\n    return {\r\n        type: APPLY_END_MASKED_NODE,\r\n        payload: {row, col}\r\n    }\r\n}\r\n\r\nexport const resetStartMaskedNode = () => {\r\n    return {\r\n        type: RESET_START_MASKED_NODE\r\n    }\r\n}\r\n\r\nexport const resetEndMaskedNode = () => {\r\n    return {\r\n        type: RESET_END_MASKED_NODE\r\n    }\r\n}","import React from 'react'\r\nimport '../css/Node.css'\r\nimport { connect } from 'react-redux'\r\nimport { toggleWallNode, setDraggedNode, clearDraggedNode, setStartNode, setEndNode, setStartMaskedNode, setEndMaskedNode, \r\n    setParentNode, rerunAlgorithm, clearPath, applyStartMaskedNode, applyEndMaskedNode, resetEndMaskedNode, resetStartMaskedNode } from '../actions'\r\nimport { nodeEquals, isAlgorithmCompleted, isAlgorithmRunning } from '../utils/AlgorithmUtil'\r\n\r\nfunction Node({isVisitedNode, isWallNode, isEndNode, isStartNode, isFrontierNode, isPathNode,\r\n    toggleWallNode, row, col, startNode, endNode, draggedNode, setDraggedNode, clearDraggedNode,\r\n    setStartNode, setEndNode, setStartMaskedNode, applyStartMaskedNode, algorithmSelected, rerunAlgorithm,\r\n    clearPath, setEndMaskedNode, applyEndMaskedNode }) {\r\n\r\n    const handleMouseOver = () => {\r\n        if (draggedNode) {  // if there was a node being dragged to this position\r\n            if (draggedNode.isWallNode && !isVisitedNode && !isFrontierNode && !isWallNode && !isStartNode && !isEndNode) {\r\n                toggleWallNode(row, col)\r\n            } else if (draggedNode.isStartNode && !isEndNode) {  // do not allow dragging start node over end node\r\n                applyStartMaskedNode(draggedNode.row, draggedNode.col)  // restore masked node properties back to the node we came from\r\n                setStartMaskedNode(row, col)  // save the state of this node, to be reapplied to this node if we drag to somewhere else\r\n                setStartNode(row, col)  // replace the state of this node\r\n                setDraggedNode(row, col)  // update the dragged node to be this node\r\n\r\n                if (isAlgorithmCompleted()) {  // if the algorithm has status completed, run the algorithm instantly\r\n                    clearPath()\r\n                    rerunAlgorithm(algorithmSelected)\r\n                }\r\n            } else if (draggedNode.isEndNode && !isStartNode) {  // do not allow dragging end node over start node\r\n                applyEndMaskedNode(draggedNode.row, draggedNode.col)  // restore masked node properties back to the node we came from\r\n                setEndMaskedNode(row, col)  // save the state of this node, to be reapplied to this node if we drag to somewhere else\r\n                setEndNode(row, col)  // replace the state of this node\r\n                setDraggedNode(row, col)  // update the dragged node to be this node\r\n\r\n                if (isAlgorithmCompleted()) {  // if the algorithm has status completed, run the algorithm instantly\r\n                    clearPath()\r\n                    rerunAlgorithm(algorithmSelected)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const handleMouseDown = () => {\r\n        if (!isAlgorithmRunning()) {  // only allow interactions with the grid when not running\r\n            if (!nodeEquals([row, col], startNode) && !nodeEquals([row, col], endNode))\r\n                toggleWallNode(row, col)\r\n            setDraggedNode(row, col)  // this is the current node being dragged\r\n        }\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n        clearDraggedNode()\r\n    }\r\n\r\n    let nodeClass\r\n    if (isStartNode) {\r\n        nodeClass = 'start'\r\n    } else if (isEndNode) {\r\n        nodeClass = 'end'\r\n    } else if (isWallNode) {\r\n        nodeClass = 'wall'\r\n    } else if (isPathNode) {\r\n        nodeClass = 'path'\r\n    } else if (isVisitedNode) {\r\n        nodeClass = 'visited'\r\n    } else if (isFrontierNode) {\r\n        nodeClass = 'frontier'\r\n    } else {\r\n        nodeClass = 'unvisited'\r\n    }\r\n\r\n    return (\r\n        <div className={`node ${nodeClass} unselectable`} onMouseOver={handleMouseOver}\r\n            onMouseUp={handleMouseUp} onMouseDown={handleMouseDown} >\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    return {\r\n        isVisitedNode: state.board.grid[ownProps.row][ownProps.col].isVisitedNode,\r\n        isWallNode: state.board.grid[ownProps.row][ownProps.col].isWallNode,\r\n        isStartNode: state.board.grid[ownProps.row][ownProps.col].isStartNode,\r\n        isEndNode: state.board.grid[ownProps.row][ownProps.col].isEndNode,\r\n        isPathNode: state.board.grid[ownProps.row][ownProps.col].isPathNode,\r\n        isFrontierNode: state.board.grid[ownProps.row][ownProps.col].isFrontierNode,\r\n        startNode: state.board.startNode,\r\n        endNode: state.board.endNode,\r\n        draggedNode: state.board.draggedNode,\r\n        algorithmSelected: state.algorithmSelected,\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        toggleWallNode: (row, col) => dispatch(toggleWallNode(row, col)),\r\n        setParentNode: (row, col) => dispatch(setParentNode(row, col)),\r\n        setDraggedNode: (row, col) => dispatch(setDraggedNode(row, col)),\r\n        clearDraggedNode: () => dispatch(clearDraggedNode()),\r\n        setStartNode: (row, col) => dispatch(setStartNode(row, col)),\r\n        setEndNode: (row, col) => dispatch(setEndNode(row, col)),\r\n        setStartMaskedNode: (row, col) => dispatch(setStartMaskedNode(row, col)),\r\n        setEndMaskedNode: (row, col) => dispatch(setEndMaskedNode(row, col)),\r\n        applyStartMaskedNode: (row, col) => dispatch(applyStartMaskedNode(row, col)),\r\n        applyEndMaskedNode: (row, col) => dispatch(applyEndMaskedNode(row, col)),\r\n        resetStartMaskedNode: (row, col) => dispatch(resetStartMaskedNode(row, col)),\r\n        resetEndMaskedNode: (row, col) => dispatch(resetEndMaskedNode(row, col)),\r\n        rerunAlgorithm: (algorithmSelected) => dispatch(rerunAlgorithm(algorithmSelected)),\r\n        clearPath: () => dispatch(clearPath()),\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node)\r\n","import React from 'react'\r\nimport { connect } from 'react-redux'\r\nimport { generateRowKey, generateCellKey } from '../utils/GridUtil'\r\nimport Node from './Node'\r\nimport '../css/Grid.css'\r\n\r\nfunction Grid(props) {\r\n    return (\r\n        <div className='grid'>\r\n            {props.grid.map((cellRow, row) => \r\n                <div className='grid-row' key={generateRowKey(row)}>\r\n                    {cellRow.map((cell, col) => \r\n                        <Node row={row} col={col} key={generateCellKey(row, col)} />\r\n                    )}\r\n                </div>\r\n            )}\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction mapStateToProps(state) {\r\n    return {\r\n        grid: state.board.grid\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid)\r\n","import React from 'react'\r\nimport '../css/Navbar.css'\r\n\r\n\r\nfunction Navbar({ algorithmStatus, algorithmSelected, runAlgorithm, generateWalls, clearBoard, clearPath,\r\n    readyAlgorithm, clearAlgorithmState, resetStartMaskedNode, resetEndMaskedNode }) {\r\n\r\n    const handleClickRun = () => {\r\n        runAlgorithm()\r\n    }\r\n\r\n    const handleClickGenerateWalls = () => {\r\n        generateWalls()\r\n    }\r\n\r\n    const handleClickClearPath = () => {\r\n        clearPath()\r\n        // discard the state saved by any algorithm pauses\r\n        clearAlgorithmState()\r\n        readyAlgorithm()\r\n    }\r\n\r\n    const handleClickClearBoard = () => {\r\n        clearBoard()\r\n        clearAlgorithmState()\r\n        readyAlgorithm()\r\n        resetStartMaskedNode()\r\n        resetEndMaskedNode()\r\n    }\r\n\r\n    let runButtonText;\r\n    let runButtonClass;\r\n    let runButtonDisabled = '';\r\n    if (algorithmStatus === 'UNSELECTED') {\r\n        runButtonText = 'Select an Algorithm'\r\n        runButtonClass = 'unselected'\r\n        runButtonDisabled = 'true'\r\n    } else if (algorithmStatus === 'READY') {\r\n        runButtonText = 'Run'\r\n        runButtonClass = 'run'\r\n    } else if (algorithmStatus === 'PAUSED') {\r\n        runButtonText = 'Resume'\r\n        runButtonClass = 'resume'\r\n    } else if (algorithmStatus === 'RUNNING') {\r\n        runButtonText = 'Pause'\r\n        runButtonClass = 'pause'\r\n    } else {  // if 'COMPLETED'\r\n        runButtonText = 'Completed'\r\n        runButtonClass = 'completed'\r\n        runButtonDisabled = 'true'\r\n    }\r\n\r\n    return (\r\n        <nav className='navbar'>\r\n            <div className='navbar-list-container'>\r\n                <ul className='navbar-list'>\r\n                    <li className='navbar-item'>\r\n                        <button className='navbar-button navbar-normal-button' onClick={handleClickGenerateWalls}>Generate Walls</button>\r\n                    </li>\r\n                    <li className='navbar-item'>\r\n                        <button  className='navbar-button navbar-normal-button'>Select Algorithm</button>\r\n                    </li>\r\n                    <li className='navbar-item'>\r\n                        <button className={`navbar-button navbar-run-button ${runButtonClass}`} disabled={runButtonDisabled} onClick={handleClickRun}>\r\n                            {runButtonText}\r\n                        </button>\r\n                    </li>  \r\n                    <li className='navbar-item'>\r\n                        <button  className='navbar-button navbar-normal-button' onClick={handleClickClearPath}>Clear Path</button>\r\n                    </li>\r\n                    <li className='navbar-item'>\r\n                        <button  className='navbar-button navbar-normal-button' onClick={handleClickClearBoard}>Clear Board</button>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </nav>\r\n    )\r\n}\r\n\r\nexport default Navbar\r\n","import React from 'react'\r\nimport { connect } from 'react-redux'\r\nimport '../css/Statbar.css'\r\n\r\nfunction Statbar({ statistics }) {\r\n    return (\r\n        <div className='statbar'>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node start'></div>\r\n                    <span className='stat-description'>Start</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node end'></div>\r\n                    <span className='stat-description'>End</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node unvisited'></div>\r\n                    <span className='stat-description'>Unvisited</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numTotal - statistics.numVisited - statistics.numWall - statistics.numFrontier}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node visited'></div>\r\n                    <span className='stat-description'>Visited</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numVisited}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node frontier'></div>\r\n                    <span className='stat-description'>Frontier</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numFrontier}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node wall'></div>\r\n                    <span className='stat-description'>Wall</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numWall}</span>\r\n                </div>\r\n            </div>\r\n            <div className='stat-container'>\r\n                <div className='stat-node-container'>\r\n                    <div className='stat-node path'></div>\r\n                    <span className='stat-description'>Path</span>\r\n                </div>\r\n                <div>\r\n                    <span className='stat-value'>{statistics.numPath}</span>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        statistics: state.board.statistics,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Statbar)\r\n","import React from 'react'\r\nimport Grid from './Grid'\r\nimport Navbar from './Navbar'\r\nimport Statbar from './Statbar'\r\nimport Carousel from './Carousel'\r\nimport '../css/Menu.css'\r\nimport { setBFSAlgorithm, toggleVisitedNode, toggleFrontierNode, setStartNode, setEndNode,\r\n    setAlgorithmState, readyAlgorithm, runAlgorithm, pauseAlgorithm, completeAlgorithm,\r\n    togglePathNode, setParentNode, generateWalls, clearBoard, clearPath, clearAlgorithmState, \r\n    resetStartMaskedNode, resetEndMaskedNode } from '../actions'\r\nimport { connect } from 'react-redux'\r\nimport { runBFS } from '../utils/Algorithms/BFS'\r\nimport { isAlgorithmRunning, isAlgorithmCompleted, isAlgorithmReady } from '../utils/AlgorithmUtil'\r\n\r\nfunction Menu(props) {\r\n\r\n    const runAlgorithm = async () => {\r\n\r\n        if (isAlgorithmRunning()) {\r\n            props.pauseAlgorithm()\r\n            return\r\n        }\r\n        \r\n        props.runAlgorithm()  // Change algorithm status to running\r\n        \r\n        let state;\r\n        switch (props.algorithmSelected) {\r\n            case 'BFS':\r\n                state = await runBFS(props.algorithmState, props.grid, props.startNode, props.endNode, props.toggleVisitedNode, \r\n                    props.toggleFrontierNode, props.togglePathNode, props.completeAlgorithm, props.setParentNode, props.clearAlgorithmState)\r\n                break\r\n            case 'DFS':\r\n                break\r\n            case 'ASTAR':\r\n                break\r\n            case 'GREEDY':\r\n                break\r\n            default:\r\n                break\r\n        }\r\n\r\n        // We have to clear the algorithm state if it is completed or sent back to the ready state from the running state\r\n        // this happens when we click clearBoard or clearPath buttons while the algorithm is still running\r\n        if (isAlgorithmCompleted() || isAlgorithmReady()) {\r\n            props.clearAlgorithmState()\r\n        } else {\r\n            props.setAlgorithmState(state)\r\n        }\r\n        \r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <Navbar runAlgorithm={runAlgorithm} \r\n                algorithmStatus={props.algorithmStatus}\r\n                algorithmSelected={props.algorithmSelected}\r\n                generateWalls={props.generateWalls}\r\n                clearBoard={props.clearBoard}\r\n                clearPath={props.clearPath}\r\n                readyAlgorithm={props.readyAlgorithm}\r\n                clearAlgorithmState={props.clearAlgorithmState}\r\n                resetStartMaskedNode={props.resetStartMaskedNode}\r\n                resetEndMaskedNode={props.resetEndMaskedNode} />\r\n            <div className='grid-container'>\r\n                <Grid />\r\n            </div>\r\n            <div className='statbar-container'>\r\n                <Statbar />\r\n            </div>\r\n            {/* <Carousel /> */}\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        setBFSAlgorithm: () => dispatch(setBFSAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        setAlgorithmState: (state) => dispatch(setAlgorithmState(state)),\r\n        clearAlgorithmState: () => dispatch(clearAlgorithmState()),\r\n        readyAlgorithm: () => dispatch(readyAlgorithm()),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        setParentNode: (row, col, parent) => dispatch(setParentNode(row, col, parent)),\r\n        generateWalls: () => dispatch(generateWalls()),\r\n        clearBoard: () => dispatch(clearBoard()),\r\n        clearPath: () => dispatch(clearPath()),\r\n        resetStartMaskedNode: () => dispatch(resetStartMaskedNode()),\r\n        resetEndMaskedNode: () => dispatch(resetEndMaskedNode()),\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        grid: state.board.grid,\r\n        algorithmSelected: state.algorithmSelected,\r\n        startNode: state.board.startNode,\r\n        endNode: state.board.endNode,\r\n        algorithmState: state.algorithmState,\r\n        algorithmStatus: state.algorithmStatus,\r\n        statistics: state.board.statistics,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu)\r\n","import '../css/App.css';\nimport Menu from './Menu';\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Menu />\n    </div>\n  );\n}\n\nexport default App;\n","import { combineReducers } from \"redux\"\r\nimport { generateEmptyGrid, setEndNode, setFrontierNode, setPathNode, setStartNode, setVisitedNode, setWallNode,\r\n    setParentNode, generateWalls, clearBoard, clearPath, initializeStatistics, Node, applyMaskedNode, generateRerunAlgorithmGrid, calculateMaskedStatistic } from \"../utils/GridUtil\"\r\nimport { SET_BFS_ALGORITHM, SET_ASTAR_ALGORITHM, SET_DFS_ALGORITHM, SET_GREEDY_ALGORITHM,\r\n    TOGGLE_FRONTIER_NODE, TOGGLE_PATH_NODE, TOGGLE_VISITED_NODE, TOGGLE_WALL_NODE,\r\n    SET_ALGORITHM_STATE, CLEAR_ALGORITHM_STATE, SET_START_NODE, SET_END_NODE, READY_ALGORITHM, COMPLETE_ALGORITHM,\r\n    PAUSE_ALGORITHM, RUN_ALGORITHM, SET_PARENT_NODE, GENERATE_WALLS, CLEAR_BOARD, CLEAR_PATH, SET_DRAGGED_NODE, \r\n    CLEAR_DRAGGED_NODE, SET_START_MASKED_NODE, APPLY_START_MASKED_NODE, RERUN_ALGORITHM, RESET_START_MASKED_NODE,\r\n    SET_END_MASKED_NODE, APPLY_END_MASKED_NODE, RESET_END_MASKED_NODE } from '../actions'\r\n\r\nconst numRows = 20  // Grid Dimensions\r\nconst numCols = 50\r\nconst start = [9, 15]  // Start Node\r\nconst end = [9, 35]  // End Node\r\n\r\nfunction board(state = { grid: generateEmptyGrid(numRows, numCols, start, end), statistics: initializeStatistics(numRows, numCols), \r\n        draggedNode: null, startMaskedNode: new Node(), endMaskedNode: new Node(), startNode: start, endNode: end }, action) {\r\n    switch(action.type) {\r\n        case TOGGLE_VISITED_NODE: {\r\n            const { grid, statistics } = setVisitedNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case TOGGLE_WALL_NODE: {\r\n            const { grid, statistics } = setWallNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case TOGGLE_FRONTIER_NODE: {\r\n            const { grid, statistics } = setFrontierNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case TOGGLE_PATH_NODE: {\r\n            const { grid, statistics } = setPathNode(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case SET_START_NODE:\r\n            return {\r\n                ...state,\r\n                grid: setStartNode(state.grid, action.payload),\r\n                startNode: [action.payload.row, action.payload.col]\r\n            }\r\n        case SET_END_NODE:\r\n            return {\r\n                ...state,\r\n                grid: setEndNode(state.grid, action.payload),\r\n                endNode: [action.payload.row, action.payload.col]\r\n            }\r\n        case SET_PARENT_NODE:\r\n            return {\r\n                ...state,\r\n                grid: setParentNode(state.grid, action.payload)\r\n            }\r\n        case GENERATE_WALLS: {\r\n            const { grid, statistics } = generateWalls(state.grid, state.statistics)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case CLEAR_BOARD: {\r\n            const { grid, statistics } = clearBoard(state.grid, state.statistics)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case CLEAR_PATH: {\r\n            const { grid, statistics } = clearPath(state.grid, state.statistics)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        case SET_DRAGGED_NODE:\r\n            return {\r\n                ...state,\r\n                draggedNode: {\r\n                    ...state.grid[action.payload.row][action.payload.col],\r\n                    row: action.payload.row,\r\n                    col: action.payload.col,\r\n                }\r\n            }\r\n        case CLEAR_DRAGGED_NODE:\r\n            return {\r\n                ...state,\r\n                draggedNode: null\r\n            }\r\n        case SET_START_MASKED_NODE: {\r\n            const { statistics } = calculateMaskedStatistic(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                statistics,\r\n                startMaskedNode: {\r\n                    ...state.grid[action.payload.row][action.payload.col]\r\n                }\r\n            }\r\n        }\r\n        case APPLY_START_MASKED_NODE: {\r\n            const { grid, statistics } = applyMaskedNode(state.grid, state.statistics, action.payload, state.startMaskedNode)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics \r\n            }\r\n        }\r\n        case RESET_START_MASKED_NODE: \r\n            return {\r\n                ...state,\r\n                startMaskedNode: new Node()\r\n            }\r\n        case SET_END_MASKED_NODE: {\r\n            const { statistics } = calculateMaskedStatistic(state.grid, state.statistics, action.payload)\r\n            return {\r\n                ...state,\r\n                statistics,\r\n                endMaskedNode: {\r\n                    ...state.grid[action.payload.row][action.payload.col]\r\n                }\r\n            }\r\n        }\r\n        case APPLY_END_MASKED_NODE: {\r\n            const { grid, statistics } = applyMaskedNode(state.grid, state.statistics, action.payload, state.endMaskedNode)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics \r\n            }\r\n        }\r\n        case RESET_END_MASKED_NODE: \r\n            return {\r\n                ...state,\r\n                endMaskedNode: new Node()\r\n            }\r\n        case RERUN_ALGORITHM: {\r\n            const { grid, statistics } = generateRerunAlgorithmGrid(state.grid, state.startNode, \r\n                state.endNode, action.payload.algorithmSelected)\r\n            return {\r\n                ...state,\r\n                grid,\r\n                statistics\r\n            }\r\n        }\r\n        default:\r\n            return state\r\n    }\r\n} \r\n\r\nfunction algorithmStatus(state = 'READY', action) {\r\n    switch(action.type) {\r\n        case READY_ALGORITHM:\r\n            return 'READY';\r\n        case RUN_ALGORITHM:\r\n            return 'RUNNING';\r\n        case PAUSE_ALGORITHM:\r\n            return 'PAUSED';\r\n        case COMPLETE_ALGORITHM:\r\n            return 'COMPLETED';\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nfunction algorithmSelected(state = 'BFS', action) {  // we set initial to BFS for now to test\r\n    switch(action.type) {\r\n        case SET_BFS_ALGORITHM:\r\n            return 'BFS';\r\n        case SET_ASTAR_ALGORITHM:\r\n            return 'ASTAR';\r\n        case SET_DFS_ALGORITHM:\r\n            return 'DFS';\r\n        case SET_GREEDY_ALGORITHM:\r\n            return 'GREEDY';\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nfunction algorithmState(state = null, action) {  \r\n    switch(action.type) {\r\n        case SET_ALGORITHM_STATE:\r\n            return action.payload;\r\n        case CLEAR_ALGORITHM_STATE:\r\n            return null;\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nconst reducer = combineReducers({\r\n    board,\r\n    algorithmStatus,\r\n    algorithmSelected,\r\n    algorithmState\r\n})\r\n\r\nexport default reducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux';\nimport reducer from './reducers'\n\nconst store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__())\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nexport default store\n"],"sourceRoot":""}